----
## SM2

SM2（SM是“商密”的缩写）是我国商用密码的公钥密码标准，标准号为：GM/T 0003-2012。
SM2算法是基于椭圆曲线的密码算法，适用于数字签名等应用场合。

### SM2算法的使用

TencentSM实现了SM2算法的以下功能：
1. **密钥生成**，生成私钥、公钥或者公私钥对。
**注意**：
   + 公钥和私钥是配对的，支持输入私钥生成对应的公钥，或者直接生成公私钥对。
   + 生成的私钥、公钥或者公私钥对是以ASCII编码的可见字符串形式输出。
   + 公钥最开始的可见字符串是04。

2. **加密解密**，使用公钥加密，使用私钥解密。
**注意**：
   + 加密过程中有随机数参与，因此对于同样的输入，每次得到的密文不相同。
   + SM2密文由C1、C2、C3三部分构成，其中C1是随机数计算出的椭圆曲线点，C2是密文数据，C3是SM3杂凑值。
   + 初版的国密标准，密文是按C1C2C3顺序存放，新标准是按C1C3C2顺序存放。
   + 在GM/T国标中，SM2密文采用ASN.1/DER编码格式。
   + 考虑到兼容性，TencentSM支持四种密文格式：C1C3C2_ASN1、C1C3C2、C1C2C3_ASN1和C1C2C3。

3. **签名验签**，使用公钥和私钥签名，使用公钥验证签名值。
**注意**：
   + 签名过程中有随机数参与，因此对于同样的输入，每次得到的签名值不相同。
   + SM2签名值由R和S两部分构成，按RS顺序存放。
   + 在GM/T国标中，SM2签名值采用ASN.1/DER编码格式。
   + 考虑到兼容性，TencentSM支持两种签名值格式：RS_ASN1、RS。

### SM2的API说明

#### 1. SM2CtxSize

输出SM2上下文结构体sm2_ctx_t的大小。

**参数**
   + 无

**返回值**
   + 结构体sm2_ctx_t的大小（单位：字节）

#### 2. SM2InitCtx

初始化sm2_ctx_t。

**参数**
   + ctx - (入参和出参) 指向sm2_ctx_t结构体的指针。

**返回值**
   + 无

**注意**：
   + 在使用SM2接口进行密钥生成、加密解密、签名验签之前，必须调用该接口或SM2InitCtxWithPubKey( )。
   + 该接口只需调用一次，在后续的密钥生成、加密解密、签名验签运算中，无需再次调用该接口。
   + 该接口所涉及ctx不是线程安全的，如需支持多线程，可对涉及ctx参数的接口调用加锁以保证线程安全，或不同线程使用不同的ctx。
   + 如需支持多线程，推荐在不同线程使用不同的ctx，以防止加锁带来的性能损耗，ctx在SM2FreeCtx之前的整个线程生命周期可复用。

#### 3. SM2InitCtxWithPubKey

初始化sm2_ctx_t。

**参数**
   + ctx - (入参和出参) 指向sm2_ctx_t结构体的指针。
   + pubkey - (入参) 指向公钥的指针。

**返回值**
   + 无

**注意**：
   + 该接口内部基于输入的公钥进行了预处理，针对该公钥的密码运算性能将得到较大提升。
   + 对于某个固定公钥需要进行密集的密码运算场景可使用该接口来替代SM2InitCtx接口进行ctx的初始化，以获得性能提升。
   + 该接口只需调用一次，在后续的密钥生成、加密解密、签名验签运算中，无需再次调用该接口。
   + 该接口初始化的ctx仍然可以用于其他公钥相关的密码运算，但是其性能与SM2InitCtx初始化的ctx性能一致。
   + 该接口所涉及ctx不是线程安全的，如需支持多线程，可对涉及ctx参数的接口调用加锁以保证线程安全，或不同线程使用不同的ctx。
   + 如需支持多线程，推荐在不同线程使用不同的ctx，以防止加锁带来的性能损耗，ctx在SM2FreeCtx之前的整个线程生命周期可复用。

#### 4. SM2FreeCtx

释放sm2_ctx_t。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。

**返回值**
   + 无

**注意**：
   + 使用完SM2算法后，必须调用该接口释放结构体。

#### 5. generatePrivateKey

生成SM2私钥。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + out - (出参) 生成的私钥。
**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 私钥实际上为256bit的大整数，输出为256bit二进制内容Hex后的ASCII编码的可见字符串，长度为64字节。
   + 为保证字符串的结束符0，out至少需分配65字节空间。

#### 6. generatePublicKey

输入SM2私钥，生成公钥。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + privateKey - (入参) 私钥。
   + outPubKey - (出参) 生成的公钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输入的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输出的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。

#### 7. generateKeyPair

生成SM2公私钥对。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + outPriKey - (出参) 私钥。
   + outPubKey - (出参) 生成的公钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输出的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输出的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。

#### 8. SM2Encrypt

SM2加密。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。
   + 密文out按照C1C3C2_ASN1格式存放。
   + outlen等于inlen+96+ASN1编码增量长度。ASN1编码增量长度不确定，建议out分配（inlen+200）字节的空间。

#### 9. SM2EncryptWithMode

SM2加密，兼容四种密文格式。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + mode - (入参) 密文的格式。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。
   + 输入的mode指示密文out的存放格式。
   + 输入的mode支持以下四种格式：C1C3C2_ASN1、C1C3C2、C1C2C3_ASN1和C1C2C3。
   + outlen等于inlen+96+ASN1编码增量长度。ASN1编码增量长度不确定，建议out分配（inlen+200）字节的空间。

#### 10. SM2Decrypt

SM2解密。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + strPriKey - (入参) 私钥。
   + prikeyLen - (入参) 私钥的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输入的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 密文in的存放格式为C1C3C2_ASN1。
   + outlen等于inlen-96-ASN1编码增量长度。ASN1编码增量长度不确定，建议out分配（inlen-96）字节的空间。

#### 11. SM2DecryptWithMode

SM2解密，兼容四种密文格式。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + strPriKey - (入参) 私钥。
   + prikeyLen - (入参) 私钥的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + mode - (入参) 密文的格式。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输入的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 输入的mode指示密文in的存放格式。
   + 输入的mode支持以下四种格式：C1C3C2_ASN1、C1C3C2、C1C2C3_ASN1和C1C2C3。
   + outlen等于inlen-96-ASN1编码增量长度。ASN1编码增量长度不确定，建议out分配（inlen-96）字节的空间。

#### 12. SM2Sign

SM2签名。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + msg - (入参) 待签名的消息。
   + msglen - (入参) msg的字节长度。
   + id - (入参) 签名者的ID。
   + idlen - (入参) id的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。
   + strPriKey - (入参) 私钥。
   + prikeyLen - (入参) 私钥的字节长度。
   + sig - (出参) 签名结果。
   + siglen - (出参) sig的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + id的作用是加入到签名hash中，对于传入值无特殊要求。
   + 输入的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。
   + 签名结果sig的存放格式为RS_ASN1。
   + siglen等于64+ASN1编码增量长度。ASN1编码增量长度不确定，建议sig分配80字节的空间。

#### 13. SM2SignWithMode

SM2签名，兼容两种签名值格式。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + msg - (入参) 待签名的消息。
   + msglen - (入参) msg的字节长度。
   + id - (入参) 签名者的ID。
   + idlen - (入参) id的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。
   + strPriKey - (入参) 私钥。
   + prikeyLen - (入参) 私钥的字节长度。
   + sig - (出参) 签名结果。
   + siglen - (出参) sig的字节长度。
   + mode - (入参) 签名值的格式。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + id的作用是加入到签名hash中，对于传入值无特殊要求。
   + 输入的私钥是可见字符串，为保证字符串的结束符0，至少需分配65字节空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。
   + 输入的mode指示签名值sig的存放格式。
   + 输入的mode支持以下两种格式：RS_ASN1、RS。
   + siglen等于64+ASN1编码增量长度。ASN1编码增量长度不确定，建议sig分配80字节的空间。

#### 14. SM2Verify

SM2验证签名。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + msg - (入参) 被签名的消息。
   + msglen - (入参) msg的字节长度。
   + id - (入参) 签名者的ID。
   + idlen - (入参) id的字节长度。
   + sig - (入参) 签名结果。
   + siglen - (入参) sig的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输入的签名结果sig存放格式为RS_ASN1。
   + sig需分配80字节的空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。

#### 15. SM2VerifyWithMode

SM2验证签名。

**参数**
   + ctx - (入参) 指向sm2_ctx_t结构体的指针。
   + msg - (入参) 被签名的消息。
   + msglen - (入参) msg的字节长度。
   + id - (入参) 签名者的ID。
   + idlen - (入参) id的字节长度。
   + sig - (入参) 签名结果。
   + siglen - (入参) sig的字节长度。
   + strPubKey - (入参) 公钥。
   + pubkeyLen - (入参) 公钥的字节长度。
   + mode - (入参) 签名值的格式。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 输入的mode指示签名值sig的存放格式。
   + 输入的mode支持以下两种格式：RS_ASN1、RS。
   + sig需分配80字节的空间。
   + 公钥包含04标志头，椭圆曲线上的点（X坐标，Y坐标）。
   + 输入的公钥是可见字符串，为保证字符串的结束符0，至少需分配131（2 + 64 + 64 + 1）字节空间。

### SM2 Example
```C
#define RET_OK 0
#define RET_ERR -1
```
#### 1. SM2密钥生成
```C
int test_SM2_Generate_Key(void) {
  int ret = RET_OK;
  char pri[256] = {0};
  char outbuf[256] = {0};
  char outpubbuf[256] = {0};
  sm2_ctx_t pctx;
  ret |= SM2InitCtx(&pctx);
  if (generateKeyPair(&pctx, pri, outbuf) != 0) {
    ret |= RET_ERR;
    goto END;
  }
  if (generatePublicKey(&pctx, pri, outpubbuf) != 0) {
    ret |= RET_ERR;
    goto END;
  }
  if (strcmp(outbuf, outpubbuf) != 0) {
    ret |= RET_ERR;
    goto END;
  }

END:
  SM2FreeCtx(&pctx);
  return ret;
}
```

#### 2. SM2加密解密
```C
int test_SM2_Encrypt_Decrypt(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "04323A83A37A469E4D7DB5093A68441D2B426B868E9E26CD48725A078DA98067F132073BB718531AE18E29B8A57F"
      "CFD76FCD16F30DA5BBA19FC7F35682551888C2";
  const char *pri = "DC78C9E7EB5389B4562AC554E33897E2D6E36E5BDF928D7D0C0AD0726D8F9039";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_PLAIN[41] = {
        0x99,0x5B,0x94,0x98,0x69,0xF8,0x0F,0xA1,0x46,0x5A,0x9D,0x8B,0x6F,0xA7,0x59,0xEC,
        0x65,0xC3,0x02,0x0D,0x59,0xC2,0x62,0x46,0x62,0xBD,0xFF,0x05,0x9B,0xDF,0x19,0xB3,
        0x69,0xBB,0x84,0xA8,0xBC,0x83,0x0C,0x9F,0xD4
  };

  size_t size = sizeof(SM2_PLAIN) / sizeof(unsigned char);

  size_t txtlen = size + 200;
  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM2Encrypt(&ctx, SM2_PLAIN, size, pub, 130, cipher, &txtlen);
  if ((size + 96)  == txtlen) {
    ret |= RET_ERR;
  }

  unsigned char plain[size];
  memset(plain, 0x00, size);

  ret |= SM2Decrypt(&ctx, (const unsigned char*)cipher, txtlen, (const char*)pri, 64, plain, &txtlen);
  if ((size != txtlen) || (memcmp(SM2_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 3. SM2加密解密（密文格式C1C3C2_ASN1）
```C
int test_SM2_Encrypt_Decrypt_WithMode_C1C3C2_ASN1(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "04323A83A37A469E4D7DB5093A68441D2B426B868E9E26CD48725A078DA98067F132073BB718531AE18E29B8A57F"
      "CFD76FCD16F30DA5BBA19FC7F35682551888C2";
  const char *pri = "DC78C9E7EB5389B4562AC554E33897E2D6E36E5BDF928D7D0C0AD0726D8F9039";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_PLAIN[41] = {
        0x99,0x5B,0x94,0x98,0x69,0xF8,0x0F,0xA1,0x46,0x5A,0x9D,0x8B,0x6F,0xA7,0x59,0xEC,
        0x65,0xC3,0x02,0x0D,0x59,0xC2,0x62,0x46,0x62,0xBD,0xFF,0x05,0x9B,0xDF,0x19,0xB3,
        0x69,0xBB,0x84,0xA8,0xBC,0x83,0x0C,0x9F,0xD4
  };

  size_t size = sizeof(SM2_PLAIN) / sizeof(unsigned char);

  size_t txtlen = size + 200;
  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM2EncryptWithMode(&ctx, SM2_PLAIN, size, pub, 130, cipher, &txtlen, SM2CipherMode_C1C3C2_ASN1);
  if ((size + 96)  == txtlen) {
    ret |= RET_ERR;
  }

  unsigned char plain[size];
  memset(plain, 0x00, size);

  ret |= SM2DecryptWithMode(&ctx, (const unsigned char*)cipher, txtlen, (const char*)pri, 64, plain, \
                            &txtlen, SM2CipherMode_C1C3C2_ASN1);
  if ((size != txtlen) || (memcmp(SM2_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 4. SM2加密解密（密文格式C1C3C2）
```C
int test_SM2_Encrypt_Decrypt_WithMode_C1C3C2(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "04323A83A37A469E4D7DB5093A68441D2B426B868E9E26CD48725A078DA98067F132073BB718531AE18E29B8A57F"
      "CFD76FCD16F30DA5BBA19FC7F35682551888C2";
  const char *pri = "DC78C9E7EB5389B4562AC554E33897E2D6E36E5BDF928D7D0C0AD0726D8F9039";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_PLAIN[41] = {
        0x99,0x5B,0x94,0x98,0x69,0xF8,0x0F,0xA1,0x46,0x5A,0x9D,0x8B,0x6F,0xA7,0x59,0xEC,
        0x65,0xC3,0x02,0x0D,0x59,0xC2,0x62,0x46,0x62,0xBD,0xFF,0x05,0x9B,0xDF,0x19,0xB3,
        0x69,0xBB,0x84,0xA8,0xBC,0x83,0x0C,0x9F,0xD4
  };

  size_t size = sizeof(SM2_PLAIN) / sizeof(unsigned char);

  size_t txtlen = size + 200;
  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM2EncryptWithMode(&ctx, SM2_PLAIN, size, pub, 130, cipher, &txtlen, SM2CipherMode_C1C3C2);
  if ((size + 96)  != txtlen) {
    ret |= RET_ERR;
  }

  unsigned char plain[size];
  memset(plain, 0x00, size);

  ret |= SM2DecryptWithMode(&ctx, (const unsigned char*)cipher, txtlen, (const char*)pri, 64, plain, \
                            &txtlen, SM2CipherMode_C1C3C2);
  if ((size != txtlen) || (memcmp(SM2_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 5. SM2加密解密（密文格式C1C2C3_ASN1）
```C
int test_SM2_Encrypt_Decrypt_WithMode_C1C2C3_ASN1(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "04323A83A37A469E4D7DB5093A68441D2B426B868E9E26CD48725A078DA98067F132073BB718531AE18E29B8A57F"
      "CFD76FCD16F30DA5BBA19FC7F35682551888C2";
  const char *pri = "DC78C9E7EB5389B4562AC554E33897E2D6E36E5BDF928D7D0C0AD0726D8F9039";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_PLAIN[41] = {
        0x99,0x5B,0x94,0x98,0x69,0xF8,0x0F,0xA1,0x46,0x5A,0x9D,0x8B,0x6F,0xA7,0x59,0xEC,
        0x65,0xC3,0x02,0x0D,0x59,0xC2,0x62,0x46,0x62,0xBD,0xFF,0x05,0x9B,0xDF,0x19,0xB3,
        0x69,0xBB,0x84,0xA8,0xBC,0x83,0x0C,0x9F,0xD4
  };

  size_t size = sizeof(SM2_PLAIN) / sizeof(unsigned char);

  size_t txtlen = size + 200;
  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM2EncryptWithMode(&ctx, SM2_PLAIN, size, pub, 130, cipher, &txtlen, SM2CipherMode_C1C2C3_ASN1);
  if ((size + 96)  == txtlen) {
    ret |= RET_ERR;
  }

  unsigned char plain[size];
  memset(plain, 0x00, size);

  ret |= SM2DecryptWithMode(&ctx, (const unsigned char*)cipher, txtlen, (const char*)pri, 64, plain, \
                            &txtlen, SM2CipherMode_C1C2C3_ASN1);
  if ((size != txtlen) || (memcmp(SM2_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 6. SM2加密解密（密文格式C1C2C3）
```C
int test_SM2_Encrypt_Decrypt_WithMode_C1C2C3(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "04323A83A37A469E4D7DB5093A68441D2B426B868E9E26CD48725A078DA98067F132073BB718531AE18E29B8A57F"
      "CFD76FCD16F30DA5BBA19FC7F35682551888C2";
  const char *pri = "DC78C9E7EB5389B4562AC554E33897E2D6E36E5BDF928D7D0C0AD0726D8F9039";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_PLAIN[41] = {
      0x99,0x5B,0x94,0x98,0x69,0xF8,0x0F,0xA1,0x46,0x5A,0x9D,0x8B,0x6F,0xA7,0x59,0xEC,
      0x65,0xC3,0x02,0x0D,0x59,0xC2,0x62,0x46,0x62,0xBD,0xFF,0x05,0x9B,0xDF,0x19,0xB3,
      0x69,0xBB,0x84,0xA8,0xBC,0x83,0x0C,0x9F,0xD4
  };

  size_t size = sizeof(SM2_PLAIN) / sizeof(unsigned char);

  size_t txtlen = size + 200;
  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM2EncryptWithMode(&ctx, SM2_PLAIN, size, pub, 130, cipher, &txtlen, SM2CipherMode_C1C2C3);
  if ((size + 96)  != txtlen) {
    ret |= RET_ERR;
  }

  unsigned char plain[size];
  memset(plain, 0x00, size);

  ret |= SM2DecryptWithMode(&ctx, (const unsigned char*)cipher, txtlen, (const char*)pri, 64, plain, \
                            &txtlen, SM2CipherMode_C1C2C3);
  if ((size != txtlen) || (memcmp(SM2_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 7. SM2签名验签
```C
int test_SM2_Sign_Verify(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "041D9E2952A06C913BAD21CCC358905ADB3A8097DB6F2F87EB5F393284EC2B7208C30B4D9834D0120216D6F1A731"
      "64FDA11A87B0A053F63D992BFB0E4FC1C5D9AD";
  const char *pri = "3B03B35C2F26DBC56F6D33677F1B28AF15E45FE9B594A6426BDCAD4A69FF976B";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_MESSAGE[37] = {
      0x40,0x03,0x60,0x7F,0x75,0xBE,0xEE,0x81,0xA0,0x27,0xBB,0x6D,0x26,0x5B,0xA1,0x49,
      0x9E,0x71,0xD5,0xD7,0xCD,0x88,0x46,0x39,0x6E,0x11,0x91,0x61,0xA5,0x7E,0x01,0xEE,
      0xB9,0x1B,0xF8,0xC9,0xFE
  };

  size_t size = sizeof(SM2_MESSAGE) / sizeof(unsigned char);

  size_t id_len = 16;
  const char *id_str = "1234567812345678";

  size_t sig_len = 80;
  unsigned char sig[80];
  memset(sig, 0x00, sig_len);

  ret |= SM2Sign(&ctx, SM2_MESSAGE, size, id_str, id_len, pub, 130, pri, 64, sig, &sig_len);
  if (64 == sig_len) {
    ret |= RET_ERR;
  }

  ret |= SM2Verify(&ctx, SM2_MESSAGE, size, id_str, id_len, sig, sig_len, pub, 130);

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 8. SM2签名验签（签名值格式RS）
```C
int test_SM2_Sign_Verify_WithMode_RS(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "041D9E2952A06C913BAD21CCC358905ADB3A8097DB6F2F87EB5F393284EC2B7208C30B4D9834D0120216D6F1A731"
      "64FDA11A87B0A053F63D992BFB0E4FC1C5D9AD";
  const char *pri = "3B03B35C2F26DBC56F6D33677F1B28AF15E45FE9B594A6426BDCAD4A69FF976B";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_MESSAGE[37] = {
      0x40,0x03,0x60,0x7F,0x75,0xBE,0xEE,0x81,0xA0,0x27,0xBB,0x6D,0x26,0x5B,0xA1,0x49,
      0x9E,0x71,0xD5,0xD7,0xCD,0x88,0x46,0x39,0x6E,0x11,0x91,0x61,0xA5,0x7E,0x01,0xEE,
      0xB9,0x1B,0xF8,0xC9,0xFE
  };

  size_t size = sizeof(SM2_MESSAGE) / sizeof(unsigned char);

  size_t id_len = 16;
  const char *id_str = "1234567812345678";

  size_t sig_len = 80;
  unsigned char sig[80];
  memset(sig, 0x00, sig_len);

  ret |= SM2SignWithMode(&ctx, SM2_MESSAGE, size, id_str, id_len, pub, 130, pri, 64, sig, \
                        &sig_len, SM2SignMode_RS);
  if (64 != sig_len) {
    ret |= RET_ERR;
  }

  ret |= SM2VerifyWithMode(&ctx, SM2_MESSAGE, size, id_str, id_len, sig, sig_len, pub, \
                           130, SM2SignMode_RS);

  SM2FreeCtx(&ctx);
  return ret;
}
```

#### 9. SM2签名验签（签名值格式RS_ASN1）
```C
int test_SM2_Sign_Verify_WithMode_RS_ASN1(void) {
  int ret = RET_OK;
  sm2_ctx_t ctx;

  const char *pub =
      "041D9E2952A06C913BAD21CCC358905ADB3A8097DB6F2F87EB5F393284EC2B7208C30B4D9834D0120216D6F1A731"
      "64FDA11A87B0A053F63D992BFB0E4FC1C5D9AD";
  const char *pri = "3B03B35C2F26DBC56F6D33677F1B28AF15E45FE9B594A6426BDCAD4A69FF976B";

  ret |= SM2InitCtxWithPubKey(&ctx, pub);

  const unsigned char SM2_MESSAGE[37] = {
      0x40,0x03,0x60,0x7F,0x75,0xBE,0xEE,0x81,0xA0,0x27,0xBB,0x6D,0x26,0x5B,0xA1,0x49,
      0x9E,0x71,0xD5,0xD7,0xCD,0x88,0x46,0x39,0x6E,0x11,0x91,0x61,0xA5,0x7E,0x01,0xEE,
      0xB9,0x1B,0xF8,0xC9,0xFE
  };

  size_t size = sizeof(SM2_MESSAGE) / sizeof(unsigned char);

  size_t id_len = 16;
  const char *id_str = "1234567812345678";

  size_t sig_len = 80;
  unsigned char sig[80];
  memset(sig, 0x00, sig_len);

  ret |= SM2SignWithMode(&ctx, SM2_MESSAGE, size, id_str, id_len, pub, 130, pri, 64, sig, \
                        &sig_len, SM2SignMode_RS_ASN1);
  if (64 == sig_len) {
    ret |= RET_ERR;
  }

  ret |= SM2VerifyWithMode(&ctx, SM2_MESSAGE, size, id_str, id_len, sig, sig_len, pub, \
                           130, SM2SignMode_RS_ASN1);

  SM2FreeCtx(&ctx);
  return ret;
}
```

----
## SM3
SM3（SM是“商密”的缩写）是我国商用密码的杂凑密码标准，标准号为：GM/T 0004-2012。
类似于SHA256，SM3用于数据完整性保护等应用场合。

### 杂凑密码算法介绍

杂凑密码算法又称哈希算法、摘要算法，它通过一个单向散列函数，把任意长度的数据转换为一个长度固定的数据串。
因为无法通过计算结果反推出明文，因此，杂凑算法不是加密算法，不能用于加密。
因为杂凑密码算法是一个单向函数，从明文计算杂凑值容易，从杂凑值反推明文困难，因此适用于数据完整性保护。

### SM3的两种使用方式

对于任意长度的消息，SM3都会产生一个256位的杂凑值，又称哈希值、消息摘要。
TencentSM实现了如下两种方式的SM3使用：
1. **一次性计算**，直接把数据传入SM3( )接口，就输出杂凑值。
**注意**：
   + 若输入数据量较小或者可以一次性输入所有数据，推荐使用该模式。
2. **分多次计算**，先调用SM3Init( )，然后对每次输入的数据，调用SM3Update( )，最后调用SM3Final( )输出杂凑值。
**注意**：
   + 若输入数据量很大或者无法一次性输入所有数据，推荐使用该模式。

### SM3 HMAC的两种使用方式

对于任意长度的消息和密钥，SM3 HMAC都会产生一个256位的消息认证码。
TencentSM实现了如下两种方式的SM3 HMAC使用：
1. **一次性计算**，直接把数据传入SM3_HMAC( )接口，就输出消息认证码。
**注意**：
   + 若输入数据量较小或者可以一次性输入所有数据，推荐使用该模式。
2. **分多次计算**，先调用SM3_HMAC_Init( )，然后对每次输入的数据，调用SM3_HMAC_Update( )，最后调用SM3_HMAC_Final( )输出杂凑值。
**注意**：
   + 若输入数据量很大或者无法一次性输入所有数据，推荐使用该模式。

### SM3 KDF

密钥派生函数KDF需要调用密码杂凑函数。
密钥派生函数的作用是从一个共享的秘密比特串中派生出密钥数据。
SM3 KDF基于SM3算法从共享数据派生出密钥。

### SM3的API说明

#### 1. SM3CtxSize

输出SM3上下文结构体sm3_ctx_t的大小。

**参数**
   + 无

**返回值**
   + 结构体sm3_ctx_t的大小（单位：字节）

#### 2. SM3Init

初始化sm3_ctx_t。

**参数**
   + ctx - (入参和出参) 指向sm3_ctx_t结构体的指针。

**返回值**
   + 无

#### 3. SM3Update

拼接输入数据和sm3_ctx_t中缓存数据，若不小于SM3消息分组（64字节），则进行迭代压缩，结果和剩余数据缓存到sm3_ctx_t。

**参数**
   + ctx - (入参和出参) 指向sm3_ctx_t结构体的指针。
   + data - (入参) 输入的数据。
   + data_len - (入参) data的字节长度。

**返回值**
   + 无

#### 4. SM3Final

对sm3_ctx_t中缓存的数据进行填充和迭代压缩，输出杂凑值。

**参数**
   + ctx - (入参) 指向sm3_ctx_t结构体的指针。
   + digest - (出参) 计算得到的杂凑值。

**返回值**
   + 无

#### 5. SM3

输入数据，输出其对应的杂凑值。

**参数**
   + data - (入参) 输入的数据。
   + data_len - (入参) data的字节长度。
   + digest - (出参) 计算得到的杂凑值。

**返回值**
   + 无

### SM3 HMAC的API说明

#### 1. SM3_HMAC_Init

输入密钥，初始化。

**参数**
   + key - (入参) 密钥。
   + keylen - (入参) 密钥的字节长度。

**返回值**
   + 指向TstHmacSm3Ctx结构体的非空指针
   + NULL

#### 2. SM3_HMAC_Update

拼接输入数据和TstHmacSm3Ctx中缓存数据，若不小于SM3消息分组（64字节），则进行迭代压缩，结果和剩余数据缓存到TstHmacSm3Ctx。

**参数**
   + ctx - (入参和出参) 指向TstHmacSm3Ctx结构体的指针。
   + data - (入参) 输入的数据。
   + data_len - (入参) data的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

#### 3. SM3_HMAC_Final

对密钥和TstHmacSm3Ctx中缓存的数据进行填充和迭代压缩，输出消息认证码。

**参数**
   + ctx - (入参) 指向TstHmacSm3Ctx结构体的指针。
   + mac - (出参) 计算得到的消息认证码。

**返回值**
   + 0：成功
   + 非0：失败

#### 4. SM3_HMAC

输入数据和密钥，输出其对应的消息认证码。

**参数**
   + data - (入参) 输入的数据。
   + data_len - (入参) data的字节长度。
   + key - (入参) 密钥。
   + keylen - (入参) 密钥的字节长度。
   + mac - (出参) 计算得到的消息认证码。

**返回值**
   + 0：成功
   + 非0：失败

#### 5. SM3_KDF

基于SM3算法从共享数据派生出密钥。

**参数**
   + share - (入参) 共享数据。
   + sharelen - (入参) 共享数据长度，不可大于1024字节。
   + key - (出参) 密钥。
   + keylen - (入参) 密钥的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

### SM3 Example
```C
#define RET_OK 0
#define RET_ERR -1
#define SM3_DIGEST_LENGTH 32
```
#### 1. SM3一次性计算
```C
int test_SM3(void) {
  const unsigned char SM3_DIGEST[SM3_DIGEST_LENGTH] = {
    0x52,0xfd,0x81,0x24,0xe9,0x26,0x75,0xe4,0xd9,0x27,0x20,0x8a,0x8c,0x7c,0x49,0xec,
    0xb3,0xfb,0xa6,0x9d,0x2d,0x9e,0x9d,0x17,0x96,0x74,0x1c,0x2d,0xe5,0xf7,0xa0,0xb2};

  const unsigned char SM3_MSG[41] = {
    0x4e,0xbe,0x3f,0x83,0x70,0x76,0xb3,0xbf,0x9a,0xf1,0x8c,0xd3,0x9c,0xdf,0x64,0xce,
    0x83,0xe9,0x5f,0x4c,0xae,0xbe,0x57,0x67,0x68,0x35,0x62,0x75,0xe1,0x6a,0x7b,0xf7,
    0xb7,0x14,0x7f,0x15,0x39,0x06,0xfb,0xc2,0x37};

  int ret = RET_OK;
  size_t size = sizeof(SM3_MSG) / sizeof(unsigned char);

  unsigned char digest[SM3_DIGEST_LENGTH];
  memset(digest, 0x00, SM3_DIGEST_LENGTH);

  ret |= SM3((const unsigned char*)SM3_MSG, size, digest);
  if(memcmp(digest, SM3_DIGEST, SM3_DIGEST_LENGTH)) {
    ret |= RET_ERR;
  }
  return ret;
}
```

#### 2. SM3分多次计算
```C
int test_SM3_Steps(void) {
  const unsigned char SM3_DIGEST[SM3_DIGEST_LENGTH] = {
    0x52,0xfd,0x81,0x24,0xe9,0x26,0x75,0xe4,0xd9,0x27,0x20,0x8a,0x8c,0x7c,0x49,0xec,
    0xb3,0xfb,0xa6,0x9d,0x2d,0x9e,0x9d,0x17,0x96,0x74,0x1c,0x2d,0xe5,0xf7,0xa0,0xb2};

  const unsigned char SM3_MSG[41] = {
    0x4e,0xbe,0x3f,0x83,0x70,0x76,0xb3,0xbf,0x9a,0xf1,0x8c,0xd3,0x9c,0xdf,0x64,0xce,
    0x83,0xe9,0x5f,0x4c,0xae,0xbe,0x57,0x67,0x68,0x35,0x62,0x75,0xe1,0x6a,0x7b,0xf7,
    0xb7,0x14,0x7f,0x15,0x39,0x06,0xfb,0xc2,0x37};

  int ret = RET_OK;
  size_t size = sizeof(SM3_MSG) / sizeof(unsigned char);

  unsigned char digest[SM3_DIGEST_LENGTH];
  memset(digest, 0x00, SM3_DIGEST_LENGTH);

  sm3_ctx_t *ctx = (sm3_ctx_t*)malloc(SM3CtxSize());
  if(NULL != ctx) {
    ret |= SM3Init(ctx);
    ret |= SM3Update(ctx, (const unsigned char *)SM3_MSG, 10);
    ret |= SM3Update(ctx, (const unsigned char *)(SM3_MSG + 10), 20);
    ret |= SM3Update(ctx, (const unsigned char *)(SM3_MSG + 10 + 20), size - (10 + 20));
    ret |= SM3Final(ctx, digest);
    free(ctx);
    ctx = NULL;
    if(memcmp(digest, SM3_DIGEST, SM3_DIGEST_LENGTH) != 0) {
      ret |= RET_ERR;
    }
  } else {
      ret |= RET_ERR;
  }
  return ret;
}
```

### SM3 HMAC Example
```C
#define RET_OK 0
#define RET_ERR -1
#define SM3_HMAC_SIZE 32
```
#### 1. SM3 HMAC一次性计算
```C
int test_SM3_HMAC(void) {
  const unsigned char SM3_MAC[SM3_HMAC_SIZE] = {
    0x13,0xc1,0xd5,0xa3,0xe2,0x46,0x2f,0xe0,0x66,0xa7,0xad,0xc0,0x6b,0x78,0xd5,0xea,
    0xc4,0x3c,0xb3,0x40,0x4b,0xd3,0xef,0x85,0x5f,0x95,0x51,0x68,0x5d,0x5d,0x70,0xa3};

  const unsigned char SM3_KEY[16] = {
    0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

  const unsigned char SM3_MSG[41] = {
    0x4e,0xbe,0x3f,0x83,0x70,0x76,0xb3,0xbf,0x9a,0xf1,0x8c,0xd3,0x9c,0xdf,0x64,0xce,
    0x83,0xe9,0x5f,0x4c,0xae,0xbe,0x57,0x67,0x68,0x35,0x62,0x75,0xe1,0x6a,0x7b,0xf7,
    0xb7,0x14,0x7f,0x15,0x39,0x06,0xfb,0xc2,0x37};

  int ret = RET_OK;
  size_t size = sizeof(SM3_MSG) / sizeof(unsigned char);
  size_t keylen = 16;

  unsigned char mac[SM3_HMAC_SIZE];
  memset(mac, 0x00, SM3_HMAC_SIZE);

  ret |= SM3_HMAC((const unsigned char*)SM3_MSG, size, (const unsigned char*)SM3_KEY, keylen, mac);
  if(memcmp(mac, SM3_MAC, SM3_HMAC_SIZE)) {
    ret |= RET_ERR;
  }
  return ret;
}
```

#### 2. SM3 HMAC分多次计算
```C
int test_SM3_HMAC_Steps(void) {
  const unsigned char SM3_MAC[SM3_HMAC_SIZE] = {
    0x13,0xc1,0xd5,0xa3,0xe2,0x46,0x2f,0xe0,0x66,0xa7,0xad,0xc0,0x6b,0x78,0xd5,0xea,
    0xc4,0x3c,0xb3,0x40,0x4b,0xd3,0xef,0x85,0x5f,0x95,0x51,0x68,0x5d,0x5d,0x70,0xa3};

  const unsigned char SM3_KEY[16] = {
    0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

  const unsigned char SM3_MSG[41] = {
    0x4e,0xbe,0x3f,0x83,0x70,0x76,0xb3,0xbf,0x9a,0xf1,0x8c,0xd3,0x9c,0xdf,0x64,0xce,
    0x83,0xe9,0x5f,0x4c,0xae,0xbe,0x57,0x67,0x68,0x35,0x62,0x75,0xe1,0x6a,0x7b,0xf7,
    0xb7,0x14,0x7f,0x15,0x39,0x06,0xfb,0xc2,0x37};

  int ret = RET_OK;
  size_t size = sizeof(SM3_MSG) / sizeof(unsigned char);
  size_t keylen = 16;

  unsigned char mac[SM3_HMAC_SIZE];
  memset(mac, 0x00, SM3_HMAC_SIZE);

  TstHmacSm3Ctx *ctx = SM3_HMAC_Init((const unsigned char *)SM3_KEY, keylen);
  if(NULL != ctx) {
    ret |= SM3_HMAC_Update(ctx, (const unsigned char *)SM3_MSG, 10);
    ret |= SM3_HMAC_Update(ctx, (const unsigned char *)(SM3_MSG + 10), 20);
    ret |= SM3_HMAC_Update(ctx, (const unsigned char *)(SM3_MSG + 10 + 20), size - (10 + 20));
    ret |= SM3_HMAC_Final(ctx, mac);
    if(memcmp(mac, SM3_MAC, SM3_HMAC_SIZE) != 0) {
      ret |= RET_ERR;
    }
  } else {
      ret |= RET_ERR;
  }
  return ret;
}
```

### SM3 KDF Example
```C
int test_SM3KDF(void) {
  int ret = RET_OK;
  unsigned char share[48] = {
    0x57,0xe7,0xb6,0x36,0x23,0xfa,0xe5,0xf0,0x8c,0xda,0x46,0x8e,0x87,0x2a,0x20,0xaf,
    0xa0,0x3d,0xed,0x41,0xbf,0x14,0x03,0x77,0x0e,0x04,0x0d,0xc8,0x3a,0xf3,0x1a,0x67,
    0x99,0x1f,0x2b,0x01,0xeb,0xf9,0xef,0xd8,0x88,0x1f,0x0a,0x04,0x93,0x00,0x06,0x03};

  unsigned char outkey[19] = {0};

  unsigned char key[19] = {
    0x04,0x6b,0x04,0xa9,0xad,0xf5,0x3b,0x38,0x9b,0x9e,0x2a,0xaf,0xb4,0x7d,0x90,0xf4,
    0xd0,0x89,0x78};

  if(SM3KDF(share, 48, outkey, 19)) {
     ret |= RET_ERR;
  }
  if(memcmp(outkey, key, 19)) {
     ret |= RET_ERR;
  }
  return ret;
}
```

----
## SM4

SM4（SM是“商密”的缩写）是我国商用密码的分组密码标准，标准号为：GM/T 0002-2012。
类似于AES，SM4用于通信加密、数据加密等应用场合。

### 分组密码算法的工作模式

分组密码的工作模式允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。
分组密码自身只能加密长度等于密码分组长度的单块数据。
若要加密变长数据，则数据必须先被划分为一些单独的密码块。
同时，最后一块数据也需要使用合适的填充方式将数据扩展到符合密码块大小的长度。

### SM4的工作模式

TencentSM实现了如下三种工作模式：
1. **SM4-ECB**，该模式提供数据加密和解密功能，对输入的明文数据支持填充和不填充两种选择。
**注意**：
   + 若输入数据的长度大于SM4算法分组长度（16字节），不推荐使用该模式。
2. **SM4-CBC**，该模式提供数据加密和解密功能，对输入的明文数据支持填充和不填充两种选择。
**注意**：
   + 与ECB模式相比，该模式需要输入初始化向量（iv）
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。
3. **SM4-CTR**，该模式提供数据加密和解密功能，对输入的明文数据不需要填充。
**注意**：
   + 与ECB模式相比，该模式需要输入初始化向量（iv）。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。
4. **SM4-GCM**，该模式同时提供数据加密和完整性保护，对输入的明文数据支持填充和不填充两种选择。
**注意**：
   + 推荐使用该模式。
   + 该模式提供数据完整性保护，因此在加密数据时无需再提供格外的MAC。
   + GCM模式初始向量（iv）的长度与CBC模式不同，不一定需要使用128bit。
   + 为了兼容，本算法库支持两套GCM模式接口，分别是带‘_NIST_SP800_38D‘和不带’_NIST_SP800_38D‘的接口。
   + 不带_NIST_SP800_38D的接口，用于兼容老版本，内部默认使用8字节的iv。
   + 带_NIST_SP800_38D的接口，新增入参ivlen，用于指示iv的字节长度。
   + GCM模式可不填充明文，若输入明文的长度大于SM4算法分组长度（16字节），推荐使用带有’_NoPadding‘的接口。

### SM4的API说明

#### 1. generateSM4Key

生成16字节的SM4 Key.

**参数**
   + outKey - (出参) 16字节的密钥.

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 也可调用该接口生成SM4 CBC模式的初始化向量iv，因为iv长度也是16字节。

#### 2. SM4_ECB_Encrypt_NoPadding

SM4 ECB模式对称加密，无填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + out需分配inlen字节的空间。

#### 3. SM4_ECB_Decrypt_NoPadding

SM4 ECB模式对称解密，无填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + out需分配inlen字节的空间。

#### 4. SM4_ECB_Encrypt

SM4 ECB模式对称加密，自动添加PKCS#7填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 该接口自动填充in，无需应用进行填充。
   + out需分配不少于（inlen + 16 - inlen % 16）字节的空间。

#### 5. SM4_ECB_Decrypt

SM4 ECB模式对称解密，自动移除PKCS#7填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + 若in解密后得到的中间结果不符合PKCS7填充标准，则outlen等于0。
   + 该接口自动去掉填充后得到out，并输出out的字节长度outlen。
   + out需分配不少于inlen字节的空间。

#### 6. SM4_CBC_Encrypt_NoPadding

SM4 CBC模式对称加密，无填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + out需分配inlen字节的空间。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 7. SM4_CBC_Decrypt_NoPadding

SM4 CBC模式对称解密，无填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + out需分配inlen字节的空间。

#### 8. SM4_CBC_Encrypt

SM4 CBC模式对称加密，自动添加PKCS#7填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 该接口自动填充in，无需应用进行填充。
   + out需分配不少于（inlen + 16 - inlen % 16）字节的空间。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 9. SM4_CBC_Decrypt

SM4 CBC模式对称解密，自动移除PKCS#7填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + 若in解密后得到的中间结果不符合PKCS7填充标准，则outlen等于0。
   + 该接口自动去掉填充后得到out，并输出out的字节长度outlen。
   + out需分配不少于inlen字节的空间。

#### 10. SM4_CTR_Encrypt_NoPadding

SM4 CTR模式对称加密，无填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 11. SM4_CTR_Decrypt_NoPadding

SM4 CTR模式对称解密，无填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 16字节的初始化向量。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。

#### 12. SM4_GCM_Encrypt_NoPadding

SM4 GCM模式认证加密，无填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + tag - (出参) 消息验证码，即MAC值。
   + taglen - (入参和出参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。
   + tag的长度不超过16字节，若输入的taglen大于16，则输出的taglen等于16。
   + aad可以为空。
   + 该接口内部默认使用8字节的iv。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 13. SM4_GCM_Decrypt_NoPadding

SM4 CBC模式认证解密，无填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + tag - (入参) 消息验证码，即MAC值。
   + taglen - (入参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。

#### 14. SM4_GCM_Encrypt

SM4 GCM模式认证加密，自动添加PKCS#7填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + tag - (出参) 消息验证码，即MAC值。
   + taglen - (入参和出参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配不少于（inlen + 16 - inlen % 16）字节的空间。
   + tag的长度不超过16字节，若输入的taglen大于16，则输出的taglen等于16。
   + aad可以为空。
   + 该接口自动填充in，无需应用进行填充。
   + 该接口内部默认使用8字节的iv。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 15. SM4_GCM_Decrypt

SM4 GCM模式认证解密，自动移除PKCS#7填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + tag - (入参) 消息验证码，即MAC值。
   + taglen - (入参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + 若in解密后得到的中间结果不符合PKCS7填充标准，则outlen等于0。
   + 该接口自动去掉填充后得到out，并输出out的字节长度outlen。
   + out需分配不少于inlen字节的空间。

#### 16. SM4_GCM_Encrypt_NoPadding_NIST_SP800_38D

SM4 GCM模式认证加密，无填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + tag - (出参) 消息验证码，即MAC值。
   + taglen - (入参和出参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + ivlen - (入参) iv的字节长度。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。
   + tag的长度不超过16字节，若输入的taglen大于16，则输出的taglen等于16。
   + aad可以为空。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 17. SM4_GCM_Decrypt_NoPadding_NIST_SP800_38D

SM4 CBC模式认证解密，无填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + tag - (入参) 消息验证码，即MAC值。
   + taglen - (入参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + ivlen - (入参) iv的字节长度。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配inlen字节的空间。

#### 18. SM4_GCM_Encrypt_NIST_SP800_38D

SM4 GCM模式认证加密，自动添加PKCS#7填充。

**参数**
   + in - (入参) 待加密的明文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 加密得到的密文。
   + outlen - (出参) out的字节长度。
   + tag - (出参) 消息验证码，即MAC值。
   + taglen - (入参和出参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + ivlen - (入参) iv的字节长度。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + out需分配不少于（inlen + 16 - inlen % 16）字节的空间。
   + tag的长度不超过16字节，若输入的taglen大于16，则输出的taglen等于16。
   + aad可以为空。
   + 该接口自动填充in，无需应用进行填充。
   + 应当使用密码学意义上安全的随机数作为iv。
   + iv应当公开，无须保密。
   + 不应当在使用同一密钥的情况下两次使用同一个iv。

#### 19. SM4_GCM_Decrypt_NIST_SP800_38D

SM4 GCM模式认证解密，自动移除PKCS#7填充。

**参数**
   + in - (入参) 待解密的密文。
   + inlen - (入参) in的字节长度。
   + out - (出参) 解密得到的明文。
   + outlen - (出参) out的字节长度。
   + tag - (入参) 消息验证码，即MAC值。
   + taglen - (入参) tag的字节长度。
   + key - (入参) 16字节的密钥。
   + iv - (入参) 初始化向量。
   + ivlen - (入参) iv的字节长度。
   + aad - (入参) 附加认证消息。
   + aadlen - (入参) aad的字节长度。

**返回值**
   + 0：成功
   + 非0：失败

**注意**：
   + 若inlen小于或等于0，则outlen等于0。
   + 若inlen不是SM4算法分组长度（16字节）的整数倍，则outlen等于0。
   + 若in解密后得到的中间结果不符合PKCS7填充标准，则outlen等于0。
   + 该接口自动去掉填充后得到out，并输出out的字节长度outlen。
   + out需分配不少于inlen字节的空间。

### SM4 Example
```C
#define RET_OK 0
#define RET_ERR -1
#define SM4_KEYBYTE_LENGTH 16
#define SM4_IV_LENGTH 16
```
#### 1. SM4 ECB
```C
int test_SM4_ECB_Encrypt_Decrypt_NoPadding(void) {
  const unsigned char SM4_ECB_PLAIN[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                             0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_ECB_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_ECB_CIPHER[16] = {0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
                                              0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46};
  int ret = RET_OK;
  size_t size = sizeof(SM4_ECB_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_ECB_Encrypt_NoPadding((const unsigned char*)SM4_ECB_PLAIN, size, cipher, &txtlen,
                            (const unsigned char*)SM4_ECB_KEY);
  if ((size != txtlen) || (memcmp(SM4_ECB_CIPHER, cipher, txtlen))) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_ECB_Decrypt_NoPadding((const unsigned char*)cipher, txtlen, plain, &txtlen,
                            (const unsigned char*)SM4_ECB_KEY);
  if ((size != txtlen) || (memcmp(SM4_ECB_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  return ret;
}

int test_SM4_ECB_Encrypt_Decrypt(void) {
  const unsigned char SM4_PLAIN[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                         0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                       0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CIPHER[32] = {0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
                                       0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
                                       0x00, 0x2a, 0x8a, 0x4e, 0xfa, 0x86, 0x3c, 0xca,
                                       0xd0, 0x24, 0xac, 0x03, 0x00, 0xbb, 0x40, 0xd2};
  int ret = RET_OK;
  size_t size = sizeof(SM4_PLAIN) / sizeof(unsigned char);
  size_t txtlen = (size / 16 + 1) * 16;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_ECB_Encrypt((const unsigned char*)SM4_PLAIN, size, cipher, &txtlen,
                  (const unsigned char*)SM4_KEY);
  if (((size / 16 + 1) * 16 != txtlen) || (memcmp(SM4_CIPHER, cipher, txtlen))) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_ECB_Decrypt((const unsigned char*)cipher, txtlen, plain, &txtlen,
                    (const unsigned char*)SM4_KEY);

  if ((size != txtlen) || (memcmp(SM4_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }
  return ret;
}
```

#### 2. SM4 CBC
```C
int test_SM4_CBC_Encrypt_Decrypt_NoPadding(void) {
  const unsigned char SM4_CBC_PLAIN[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CBC_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CBC_IV[SM4_IV_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CBC_CIPHER[16] = {0x26, 0x77, 0xf4, 0x6b, 0x09, 0xc1, 0x22, 0xcc,
                                            0x97, 0x55, 0x33, 0x10, 0x5b, 0xd4, 0xa2, 0x2a};
  int ret = RET_OK;
  size_t size = sizeof(SM4_CBC_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_CBC_Encrypt_NoPadding((const unsigned char*)SM4_CBC_PLAIN, size, cipher, &txtlen,
                            (const unsigned char*)SM4_CBC_KEY, (const unsigned char*)SM4_CBC_IV);
  if ((size != txtlen) || (memcmp(SM4_CBC_CIPHER, cipher, txtlen))) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_CBC_Decrypt_NoPadding((const unsigned char*)cipher, txtlen, plain, &txtlen,
                            (const unsigned char*)SM4_CBC_KEY, (const unsigned char*)SM4_CBC_IV);
  if ((size != txtlen) || (memcmp(SM4_CBC_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  return ret;
}

int test_SM4_CBC_Encrypt_Decrypt(void) {
  const unsigned char SM4_PLAIN[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                       0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                       0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_IV[SM4_IV_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                       0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CIPHER[32] = {0x26, 0x77, 0xf4, 0x6b, 0x09, 0xc1, 0x22, 0xcc,
                                       0x97, 0x55, 0x33, 0x10, 0x5b, 0xd4, 0xa2, 0x2a,
                                       0x3b, 0x88, 0x0e, 0x68, 0x67, 0x77, 0x25, 0x22,
                                       0xae, 0x55, 0xd2, 0xf0, 0xae, 0x74, 0x78, 0xae};
  int ret = RET_OK;
  size_t size = sizeof(SM4_PLAIN) / sizeof(unsigned char);
  size_t txtlen = (size / 16 + 1) * 16;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_CBC_Encrypt((const unsigned char*)SM4_PLAIN, size, cipher, &txtlen,
                  (const unsigned char*)SM4_KEY,(const unsigned char*)SM4_IV);
  if (((size / 16 + 1) * 16 != txtlen) || (memcmp(SM4_CIPHER, cipher, txtlen))) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_CBC_Decrypt((const unsigned char*)cipher, txtlen, plain, &txtlen,
                  (const unsigned char*)SM4_KEY,(const unsigned char*)SM4_IV);

  if ((size != txtlen) || (memcmp(SM4_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  return ret;
}
```

#### 3. SM4 CTR
```C
int test_SM4_CTR_Encrypt_Decrypt_NoPadding(void) {
  const unsigned char SM4_CTR_PLAIN[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CTR_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CTR_IV[SM4_IV_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                           0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CTR_CIPHER[16] = {0x69, 0x3d, 0x9a, 0x53, 0x5b, 0xad, 0x5b, 0xb1,
                                           0x78, 0x6f, 0x53, 0xd7, 0x25, 0x3a, 0x70, 0x56};
  int ret = RET_OK;
  size_t size = sizeof(SM4_CTR_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_CTR_Encrypt_NoPadding((const unsigned char*)SM4_CTR_PLAIN, size, cipher, &txtlen,
                            (const unsigned char*)SM4_CTR_KEY, (const unsigned char*)SM4_CTR_IV);
  if ((size != txtlen) || (memcmp(SM4_CTR_CIPHER, cipher, txtlen))) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_CTR_Decrypt_NoPadding((const unsigned char*)cipher, txtlen, plain, &txtlen,
                            (const unsigned char*)SM4_CTR_KEY, (const unsigned char*)SM4_CTR_IV);
  if ((size != txtlen) || (memcmp(SM4_CTR_PLAIN, plain, txtlen))) {
    ret |= RET_ERR;
  }

  return ret;
}
```

#### 4. SM4 GCM
```C
int test_SM4_GCM_Encrypt_Decrypt_NoPadding(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                              0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_GCM_IV[8] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
  const unsigned char SM4_GCM_PLAIN[64] = {
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_GCM_CIPHER[64] = {
    0x9C, 0x6C, 0xA8, 0xBC, 0x56, 0x78, 0x5E, 0xF6, 0x56, 0xDB, 0x0E, 0x1C, 0xDB, 0xF9, 0x63, 0xFD,
    0xE1, 0x41, 0xAB, 0x56, 0x17, 0xD2, 0xE1, 0xD7, 0x95, 0x86, 0x70, 0x35, 0x3F, 0x37, 0x59, 0x82,
    0xFF, 0xB1, 0xC8, 0x5F, 0xAD, 0x11, 0x17, 0xC8, 0x48, 0xE2, 0x6D, 0x45, 0x7D, 0xF5, 0x77, 0xEC,
    0x82, 0xEB, 0xF9, 0x64, 0x55, 0xA7, 0xD0, 0x06, 0x70, 0xEA, 0xC1, 0x93, 0x9D, 0xCF, 0x7F, 0xB8};
  const unsigned char SM4_GCM_AAD[16] = {0x26, 0x77, 0xF4, 0x6B, 0x09, 0xC1, 0x22, 0xCC,
                                            0x97, 0x55, 0x33, 0x10, 0x5B, 0xD4, 0xA2, 0x2A};
  const unsigned char SM4_GCM_TAG[16] = {
    0x52, 0x93, 0xFA, 0xA2, 0xE8, 0xC9, 0xA6, 0x7E, 0x77, 0xF8, 0x77, 0xC7, 0xAD, 0x34, 0x9D, 0x8C};

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t aadlen = 16;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt_NoPadding((unsigned char *)SM4_GCM_PLAIN, size, cipher, &txtlen, tag, &taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_GCM_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt_NoPadding(cipher, txtlen, plain, &txtlen, tag, taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }

  return ret;
}

int test_SM4_GCM_Encrypt_Decrypt(void) {
  const unsigned char SM4_KEY[SM4_KEYBYTE_LENGTH] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                              0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_IV[8] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
  const unsigned char SM4_PLAIN[64] = {
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
  const unsigned char SM4_CIPHER[80] = {
    0x9C, 0x6C, 0xA8, 0xBC, 0x56, 0x78, 0x5E, 0xF6, 0x56, 0xDB, 0x0E, 0x1C, 0xDB, 0xF9, 0x63, 0xFD,
    0xE1, 0x41, 0xAB, 0x56, 0x17, 0xD2, 0xE1, 0xD7, 0x95, 0x86, 0x70, 0x35, 0x3F, 0x37, 0x59, 0x82,
    0xFF, 0xB1, 0xC8, 0x5F, 0xAD, 0x11, 0x17, 0xC8, 0x48, 0xE2, 0x6D, 0x45, 0x7D, 0xF5, 0x77, 0xEC,
    0x82, 0xEB, 0xF9, 0x64, 0x55, 0xA7, 0xD0, 0x06, 0x70, 0xEA, 0xC1, 0x93, 0x9D, 0xCF, 0x7F, 0xB8,
    0x77, 0x36, 0x8F, 0xB2, 0xB3, 0x03, 0x47, 0x86, 0x14, 0x0F, 0x58, 0x8B, 0x83, 0x69, 0x3F, 0x24
  };
  const unsigned char SM4_AAD[16] = {0x26, 0x77, 0xF4, 0x6B, 0x09, 0xC1, 0x22, 0xCC,
                                            0x97, 0x55, 0x33, 0x10, 0x5B, 0xD4, 0xA2, 0x2A};
  const unsigned char SM4_TAG[16] = {
    0xD5, 0x48, 0xE8, 0x4C, 0x7E, 0xB4, 0xB3, 0xAF, 0xC4, 0xC3, 0x87, 0x03, 0x39, 0x99, 0x0D, 0xE1};

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t aadlen = 16;
  size_t size = sizeof(SM4_PLAIN) / sizeof(unsigned char);
  size_t txtlen = (size / 16 + 1) * 16;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt((unsigned char *)SM4_PLAIN, size, cipher, &txtlen, tag, &taglen,
                        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV,
                        (unsigned char *)SM4_AAD, aadlen);
  if (((size / 16 + 1) * 16 != txtlen) || (memcmp(SM4_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt(cipher, txtlen, plain, &txtlen, tag, taglen,
                        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV,
                        (unsigned char *)SM4_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }

  return ret;
}

int test_SM4_GCM_Encrypt_Decrypt_NoPadding_NIST_SP800_38D(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                              0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};
  const unsigned char SM4_GCM_IV[60] = {
    0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
    0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
    0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
    0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60] = {
    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
    0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
    0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
    0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39
  };
  const unsigned char SM4_GCM_CIPHER[64] = {
    0x9a, 0x05, 0xc6, 0x8e, 0x20, 0x8a, 0x75, 0x51, 0x31, 0x51, 0x7d, 0x0a, 0xe2, 0xf2, 0xeb, 0x82,
    0x1f, 0x4b, 0x14, 0x12, 0x24, 0xd2, 0xb9, 0xf8, 0x73, 0xc6, 0x4a, 0xd0, 0x85, 0x41, 0x76, 0xdb,
    0xef, 0x27, 0xae, 0x96, 0xfd, 0x90, 0x40, 0x9f, 0x4e, 0xe2, 0x02, 0xba, 0x6e, 0x04, 0xd7, 0x34,
    0x5b, 0x55, 0x14, 0x86, 0x65, 0x02, 0xdd, 0x68, 0x8a, 0x06, 0xb2, 0xba
  };
  const unsigned char SM4_GCM_AAD[20] = {
    0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
    0xab, 0xad, 0xda, 0xd2
  };
  const unsigned char SM4_GCM_TAG[16] = {
    0x4f, 0x78, 0xdf, 0x5d, 0x96, 0xdf, 0x6d, 0xd6, 0x4e, 0x8c, 0xd8, 0x25, 0x1c, 0xc6, 0x7d, 0x31};

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt_NoPadding_NIST_SP800_38D((unsigned char *)SM4_GCM_PLAIN, size, cipher, &txtlen, tag, &taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_GCM_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt_NoPadding_NIST_SP800_38D(cipher, txtlen, plain, &txtlen, tag, taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }

  return ret;
}

int test_SM4_GCM_Encrypt_Decrypt_NIST_SP800_38D(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                              0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};
  const unsigned char SM4_GCM_IV[60] = {
    0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
    0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
    0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
    0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60] = {
    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
    0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
    0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
    0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39
  };
  const unsigned char SM4_GCM_CIPHER[64] = {
    0x9a, 0x05, 0xc6, 0x8e, 0x20, 0x8a, 0x75, 0x51, 0x31, 0x51, 0x7d, 0x0a, 0xe2, 0xf2, 0xeb, 0x82,
    0x1f, 0x4b, 0x14, 0x12, 0x24, 0xd2, 0xb9, 0xf8, 0x73, 0xc6, 0x4a, 0xd0, 0x85, 0x41, 0x76, 0xdb,
    0xef, 0x27, 0xae, 0x96, 0xfd, 0x90, 0x40, 0x9f, 0x4e, 0xe2, 0x02, 0xba, 0x6e, 0x04, 0xd7, 0x34,
    0x5b, 0x55, 0x14, 0x86, 0x65, 0x02, 0xdd, 0x68, 0x8a, 0x06, 0xb2, 0xba, 0x7e, 0xd4, 0xb0, 0x93
  };
  const unsigned char SM4_GCM_AAD[20] = {
    0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
    0xab, 0xad, 0xda, 0xd2
  };
  const unsigned char SM4_GCM_TAG[16] = {
    0xff, 0xa6, 0xc2, 0x3e, 0x97, 0xe6, 0xa7, 0x2b, 0x28, 0xd5, 0x5c, 0x9a, 0xdd, 0x13, 0x2b, 0x1d
  };

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = (size / 16 + 1) * 16;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt_NIST_SP800_38D((unsigned char *)SM4_GCM_PLAIN, size, cipher, &txtlen, tag, &taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size / 16 + 1) * 16 != txtlen || (memcmp(SM4_GCM_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_GCM_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt_NIST_SP800_38D(cipher, txtlen, plain, &txtlen, tag, taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }

  return ret;
}
```
----
