/* Copyright 2019, Tencent Technology (Shenzhen) Co Ltd

This file is part of the Tencent SM (Lite Version) Library.

The Tencent SM (Lite Version) Library is free software; you can redistribute it and/or modify
it under the terms of either:

* the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your
option) any later version.

or

* the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any
later version.

or both in parallel, as here.

The Tencent SM (Lite Version) Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received copies of the GNU General Public License and the
GNU Lesser General Public License along with the Tencent SM (Lite Version) Library.  If not,
see https://www.gnu.org/licenses/.  */

/**
 * test  interface in sm.h
 */
#include "test_global.hpp"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <iostream>
#include "../include/sm.h"
#include "../include/sm4_advance.h"

extern void random_content(size_t len, unsigned char *out);

using namespace::std;


int test_Version() {
    const char* nVersion = version();
    if(nVersion != NULL) {
        return RET_OK;
    }
    return RET_ERR;
}

int test_SM2CtxSize() {
    int size = SM2CtxSize();
    if(size > 0) {
        return RET_OK;
    }
    return RET_ERR;
}

int test_SM2InitCtx_Free() {
    sm2_ctx_t pctx;
    if(SM2InitCtx(&pctx)) {
        return RET_ERR;
    }
    if(SM2FreeCtx(&pctx)) {
        return RET_ERR;
    }
    return RET_OK;
}

int test_SM2InitCtxWithPubKey() {
    sm2_ctx_t pctx;
    if(SM2InitCtxWithPubKey(&pctx, SM2_PUBKEY)) {
        return RET_ERR;
    }
    if(SM2FreeCtx(&pctx)) {
        return RET_ERR;
    }
    return RET_OK;
}
int test_generatePrivateKey() {
    int ret = RET_OK;
    char outbuf[256] = {0};
    sm2_ctx_t pctx;
    ret |= SM2InitCtx(&pctx);
    if(generatePrivateKey(&pctx, outbuf) != 0) {
        ret |= RET_ERR;
        goto END;
    }
END:
    SM2FreeCtx(&pctx);
    return ret;
}
int test_generatePublicKey() {
    int ret = RET_OK;
    char outbuf[256] = {0};
    sm2_ctx_t pctx;
    ret |= SM2InitCtx(&pctx);
    if(generatePublicKey(&pctx, SM2_PRIKEY, outbuf) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    SM2FreeCtx(&pctx);
    return ret;
}
int test_generateKeyPair() {
    int ret = RET_OK;
    char pri[256] = {0};
    char outbuf[256] = {0};
    char outpubbuf[256] = {0};
    sm2_ctx_t pctx;
    ret |= SM2InitCtx(&pctx);
    if(generateKeyPair(&pctx, pri, outbuf) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    if(generatePublicKey(&pctx, pri, outpubbuf) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    if(strcmp(outbuf, outpubbuf) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM2Decrypt() {
    int ret = RET_OK;
    unsigned char outbuf[256] = {0x00};
    size_t outlen = 256;
    sm2_ctx_t pctx;
    size_t cipher_len = strlen(SM2_CIPHERTXT)/2;
    unsigned char bytecipher[cipher_len];

    tc_hex2bin(SM2_CIPHERTXT, bytecipher);
    SM2InitCtx(&pctx);
    if(SM2Decrypt(&pctx, (const unsigned char*)bytecipher, cipher_len, 
        (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), outbuf, &outlen) != 0) {
        ret |= RET_ERR;
        goto END;
    } else {
        //compare result
        if(strlen(SM2_PLAINTXT) == outlen && !memcmp(SM2_PLAINTXT, outbuf, outlen)) {
            ret = RET_OK;
        } else {
            ret |= RET_ERR;
        }
    }
END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM2Encrypt() {
    int ret = RET_OK;
    size_t plainlen = strlen(SM2_PLAINTXT);
    size_t plainlen2 = plainlen;
    size_t outlen = plainlen+220;
    unsigned char outbuf[outlen];
    unsigned char plaintxt[256];
    sm2_ctx_t pctx;
    SM2InitCtx(&pctx);
    memset(outbuf, 0x00, outlen);
    memset(plaintxt, 0x00, 256);

    if(SM2Encrypt(&pctx, (const unsigned char*)SM2_PLAINTXT, plainlen, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), outbuf, &outlen) != 0) {
        ret |= RET_ERR;
        goto END;
    }

    //因为随机数，每次加密的结果是不同的，所以用解密来验证.
    if(SM2Decrypt(&pctx, (const unsigned char*)outbuf, outlen, (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), plaintxt, &plainlen) != 0) {
        ret |= RET_ERR;
        goto END;
    } else {
        //compare result
        char tmpb[plainlen2];
        memcpy(tmpb, SM2_PLAINTXT, plainlen2);
        if(plainlen2 == plainlen && !memcmp(tmpb, plaintxt, plainlen2)) {
            ret = RET_OK;
        } else {
            ret |= RET_ERR;
        }
    }
END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM2Verify() {
    int ret = RET_OK;
    // size_t outlen = 256;
    // char outbuf[outlen];
    sm2_ctx_t pctx;
    size_t sig_len = strlen(SM2_SIGHEX)/2;
    unsigned char* bytessig = (unsigned char*)malloc(sig_len);

    tc_hex2bin(SM2_SIGHEX, bytessig);

    SM2InitCtx(&pctx);
    // memset(outbuf, 0x00, outlen);

    if(SM2Verify(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                                    (const unsigned char*)bytessig, sig_len, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY)) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    if(bytessig != NULL) {
        free(bytessig);
    }
    SM2FreeCtx(&pctx);
    return ret;
}
int test_SM2Sign() {
    int ret = RET_OK;
    size_t outlen = 256;
    unsigned char outbuf[outlen];
    sm2_ctx_t pctx;

    SM2InitCtx(&pctx);
    memset(outbuf, 0x00, outlen);

    if(SM2Sign(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                    (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), 
                    outbuf, &outlen) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    //由于随机数的问题，用verify验证
    if(SM2Verify(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                                    (const unsigned char*)outbuf, outlen, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY)) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM3CtxSize() {
    int ret = RET_OK;
    int size = SM3CtxSize();
    if(size <= 0) {
        return RET_ERR;
    }
END:
    return ret;
}

int test_SM3Init() {
    int ret = RET_OK;
    sm3_ctx_t sm3ctx;
    if(SM3Init(&sm3ctx)) {
        return RET_ERR;
    }
END:
    return ret;
}

int test_SM3UpdateFinal() {
    int ret = RET_OK;
    unsigned char outb[SM3_DIGEST_LENGTH]={0};
    char outstr[SM3_DIGEST_LENGTH*2+1] = {0};
    sm3_ctx_t sm3ctx;
    
    if(SM3Init(&sm3ctx)) {
        return RET_ERR;
    }

    if(SM3Update(&sm3ctx, (const unsigned char*)SM3_MSG, strlen(SM3_MSG))) {
        return RET_ERR;
    }
    if(SM3Final(&sm3ctx, outb)) {
        return RET_ERR;
    }
    tc_bin2hex((const unsigned char*)outb, SM3_DIGEST_LENGTH, outstr, SM3_DIGEST_LENGTH*2+1);
    if(memcmp(SM3_MD_DATA, outstr, SM3_DIGEST_LENGTH*2)) {
       ret |= RET_ERR;
    }
END:
    return ret;
}
int test_SM3() {
    int ret = RET_OK;
    unsigned char outb[SM3_DIGEST_LENGTH]={0};
    char outstr[SM3_DIGEST_LENGTH*2+1] = {0};
    if(SM3((const unsigned char*)SM3_MSG, strlen(SM3_MSG), outb)) {
        return RET_ERR;
    }
    tc_bin2hex((const unsigned char*)outb, SM3_DIGEST_LENGTH, outstr, SM3_DIGEST_LENGTH*2+1);
    if(memcmp(SM3_MD_DATA, outstr, SM3_DIGEST_LENGTH*2)) {
       ret |= RET_ERR;
    }
END:
    return ret;
}
int test_SM3_hmac_steps() {
    int ret = RET_OK;
    unsigned char outb[SM3_HMAC_SIZE]={0};
    char outstr[SM3_HMAC_SIZE*2+1] = {0};
    TstHmacSm3Ctx* sm3hmacctx = NULL;
    sm3hmacctx = SM3_HMAC_Init((const unsigned char*)SM3_HMAC_KEY, strlen(SM3_HMAC_KEY));
    if(sm3hmacctx == NULL) {
        ret |= RET_ERR;
        goto END;
    }
    if(SM3_HMAC_Update(sm3hmacctx, (const unsigned char*)SM3_MSG, strlen(SM3_MSG)) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    if(SM3_HMAC_Final(sm3hmacctx, outb) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    tc_bin2hex((const unsigned char*)outb, SM3_DIGEST_LENGTH, outstr, SM3_DIGEST_LENGTH*2+1);
    if(memcmp(SM3_HMAC_RET, outstr, SM3_HMAC_SIZE*2)) {
       ret |= RET_ERR;
    }
END:
    return ret;
}
int test_SM3_hmac() {
    int ret = RET_OK;
    unsigned char outb[SM3_HMAC_SIZE]={0};
    char outstr[SM3_HMAC_SIZE*2+1] = {0};
    ret |= SM3_HMAC((const unsigned char*)SM3_MSG, strlen(SM3_MSG), (const unsigned char*)SM3_HMAC_KEY, strlen(SM3_HMAC_KEY), outb);
    tc_bin2hex((const unsigned char*)outb, SM3_DIGEST_LENGTH, outstr, SM3_DIGEST_LENGTH*2+1);
    if(memcmp(SM3_HMAC_RET, outstr, SM3_HMAC_SIZE*2)) {
       ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM3KDF(){
  int ret = RET_OK;
  unsigned char share[48] = {0x57,0xE7,0xB6,0x36,0x23,0xFA,0xE5,0xF0,0x8C,0xDA,0x46,0x8E,0x87,0x2A,0x20,0xAF,0xA0,0x3D,
    0xED,0x41,0xBF,0x14,0x03,0x77,0x0E,0x04,0x0D,0xC8,0x3A,0xF3,0x1A,0x67,0x99,0x1F,0x2B,0x01,0xEB,0xF9,0xEF,0xD8,0x88,0x1F,0x0A,0x04,0x93,0x00,0x06,0x03};
  
  unsigned char outkey[19] = {0};
  
  unsigned char key[19] = {0x04,0x6B,0x04,0xA9,0xAD,0xF5,0x3B,0x38,0x9B,0x9E,0x2A,0xAF,0xB4,0x7D,0x90,0xF4,0xD0,0x89,0x78};
  
  if(SM3KDF(share, 48, outkey, 19)) {
     ret |= RET_ERR;
    goto END;
  }
  
  if(memcmp(outkey, key, 19)) {
     ret |= RET_ERR;
  }
  
END:
  return ret;
}

int test_generateSM4Key() {
    int ret = RET_OK;
    unsigned char outb[SM4_KEYBYTE_LENGTH]={0};

    if(generateSM4Key(outb)) {
       ret |= RET_ERR;
        goto END;
    }
END:
    return ret;
}

int test_SM4_CBC_Encrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CBC_Encrypt((const unsigned char*)SM4_PLAIN, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if(((size/16+1)*16 != txtlen) ||(memcmp(SM4_CBC_CIPHER_WITH_PADDING, outb, txtlen))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_CBC_Decrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_CBC_CIPHER_WITH_PADDING)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CBC_Decrypt((const unsigned char*)SM4_CBC_CIPHER_WITH_PADDING, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if((sizeof(SM4_PLAIN)/sizeof(unsigned char) != txtlen) ||(memcmp(SM4_PLAIN, outb, txtlen))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_CBC_Encrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CBC_Encrypt_NoPadding((const unsigned char*)SM4_PLAIN, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_CBC_CIPHER, outb, txtlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_CBC_Decrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_CBC_CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CBC_Decrypt_NoPadding((const unsigned char*)SM4_CBC_CIPHER, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_PLAIN, outb, txtlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_ECB_Encrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);
    
    if(SM4_ECB_Encrypt((const unsigned char*)SM4_PLAIN, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY)) {
        ret |= RET_ERR;
        goto END;
    }
    if(((size/16+1)*16 != txtlen) ||(memcmp(SM4_ECB_CIPHER_WITH_PADDING, outb, txtlen))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_ECB_Decrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_ECB_CIPHER_WITH_PADDING)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_ECB_Decrypt((const unsigned char*)SM4_ECB_CIPHER_WITH_PADDING, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY)) {
        ret |= RET_ERR;
        goto END;
    }
    if((sizeof(SM4_PLAIN)/sizeof(unsigned char) != txtlen) ||(memcmp(SM4_PLAIN, outb, txtlen))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_ECB_Encrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_ECB_Encrypt_NoPadding((const unsigned char*)SM4_PLAIN, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_ECB_CIPHER, outb, sizeof(SM4_ECB_CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_ECB_Decrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_ECB_CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_ECB_Decrypt_NoPadding((const unsigned char*)SM4_ECB_CIPHER, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_CTR_Encrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CTR_Encrypt_NoPadding((const unsigned char*)SM4_PLAIN, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_CTR_CIPHER, outb, txtlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_CTR_Decrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_CTR_CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];

    memset(outb, 0x00, txtlen);

    if(SM4_CTR_Decrypt_NoPadding((const unsigned char*)SM4_CTR_CIPHER, size, outb, &txtlen,
        (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV)) {
        ret |= RET_ERR;
        goto END;
    }
    if(memcmp(SM4_PLAIN, outb, txtlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_GCM_Encrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_GCM_TEST_PLAIN)/sizeof(unsigned char);
    size_t outlen = (size/16+1)*16;
    unsigned char out[outlen];
    memset(out, 0x00, outlen);
  
    size_t taglen = 16;
    unsigned char tag[taglen];
    memset(tag, 0x00, taglen);
  
    ret = SM4_GCM_Encrypt(SM4_GCM_TEST_PLAIN, SM4_GCM_TEST_PLAIN_LEN, out, &outlen, tag, &taglen, SM4_GCM_TEST_KEY, SM4_GCM_TEST_IV, SM4_GCM_TEST_AAD, 16);
    if (memcmp(SM4_GCM_TEST_CIPHER, out, outlen) != 0 || memcmp(SM4_GCM_TEST_TAG, tag, taglen) != 0) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_GCM_Decrypt() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_GCM_TEST_CIPHER)/sizeof(unsigned char);
    size_t outlen = size;
    unsigned char out[outlen];
    memset(out, 0x00, outlen);
  
    ret = SM4_GCM_Decrypt(SM4_GCM_TEST_CIPHER, SM4_GCM_TEST_CIPHER_LEN, out, &outlen, SM4_GCM_TEST_TAG, 16, SM4_GCM_TEST_KEY, SM4_GCM_TEST_IV,SM4_GCM_TEST_AAD, 16);
    if(ret != 0 || memcmp(SM4_GCM_TEST_PLAIN, out, outlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_GCM_Encrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_GCM_TEST_PLAIN)/sizeof(unsigned char);
    size_t outlen = (size/16+1)*16;
    unsigned char out[outlen];
    memset(out, 0x00, outlen);
  
    size_t taglen = 16;
    unsigned char tag[taglen];
    memset(tag, 0x00, taglen);
  
    ret |= SM4_GCM_Encrypt_NoPadding(SM4_GCM_TEST_PLAIN, SM4_GCM_TEST_PLAIN_LEN, out, &outlen, tag, &taglen, SM4_GCM_TEST_KEY, SM4_GCM_TEST_IV,SM4_GCM_TEST_AAD, 16);
    if (memcmp(SM4_GCM_TEST_CIPHER_NOPADDING, out, outlen) != 0 || memcmp(SM4_GCM_TEST_TAG_NOPADDING, tag, taglen) != 0) {
        ret |= RET_ERR;
    }
END:
    return ret;
}
int test_SM4_GCM_Decrypt_NoPadding() {
    int ret = RET_OK;
    size_t size = sizeof(SM4_GCM_TEST_CIPHER_NOPADDING)/sizeof(unsigned char);
    size_t outlen = size;
    unsigned char out[outlen];
    memset(out, 0x00, outlen);
  
    ret = SM4_GCM_Decrypt_NoPadding(SM4_GCM_TEST_CIPHER_NOPADDING, SM4_GCM_TEST_CIPHER_NOPADDING_LEN, out, &outlen, SM4_GCM_TEST_TAG_NOPADDING, 16, SM4_GCM_TEST_KEY, SM4_GCM_TEST_IV, SM4_GCM_TEST_AAD, 16);
    if(ret != 0 || memcmp(SM4_GCM_TEST_PLAIN, out, outlen)) {
        ret |= RET_ERR;
    }
END:
    return ret;
}

int test_SM4_GCM_Encrypt_Decrypt_NoPadding_NIST_SP800_38D(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                              0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};
  const unsigned char SM4_GCM_IV[60] = {
    0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
    0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
    0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
    0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60] = {
    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
    0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
    0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
    0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39
  };
  const unsigned char SM4_GCM_CIPHER[64] = {
    0x9a, 0x05, 0xc6, 0x8e, 0x20, 0x8a, 0x75, 0x51, 0x31, 0x51, 0x7d, 0x0a, 0xe2, 0xf2, 0xeb, 0x82,
    0x1f, 0x4b, 0x14, 0x12, 0x24, 0xd2, 0xb9, 0xf8, 0x73, 0xc6, 0x4a, 0xd0, 0x85, 0x41, 0x76, 0xdb,
    0xef, 0x27, 0xae, 0x96, 0xfd, 0x90, 0x40, 0x9f, 0x4e, 0xe2, 0x02, 0xba, 0x6e, 0x04, 0xd7, 0x34,
    0x5b, 0x55, 0x14, 0x86, 0x65, 0x02, 0xdd, 0x68, 0x8a, 0x06, 0xb2, 0xba
  };
  const unsigned char SM4_GCM_AAD[20] = {
    0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
    0xab, 0xad, 0xda, 0xd2
  };
  const unsigned char SM4_GCM_TAG[16] = {
    0x4f, 0x78, 0xdf, 0x5d, 0x96, 0xdf, 0x6d, 0xd6, 0x4e, 0x8c, 0xd8, 0x25, 0x1c, 0xc6, 0x7d, 0x31};

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt_NoPadding_NIST_SP800_38D((unsigned char *)SM4_GCM_PLAIN, size, cipher, &txtlen, tag, &taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_GCM_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt_NoPadding_NIST_SP800_38D(cipher, txtlen, plain, &txtlen, tag, taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }
   
  return ret;
}

int test_SM4_GCM_Encrypt_Decrypt_NIST_SP800_38D(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                              0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};
  const unsigned char SM4_GCM_IV[60] = {
    0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
    0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
    0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
    0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 0xa6, 0x37, 0xb3, 0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60] = {
    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
    0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
    0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
    0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39
  };
  const unsigned char SM4_GCM_CIPHER[64] = {
    0x9a, 0x05, 0xc6, 0x8e, 0x20, 0x8a, 0x75, 0x51, 0x31, 0x51, 0x7d, 0x0a, 0xe2, 0xf2, 0xeb, 0x82,
    0x1f, 0x4b, 0x14, 0x12, 0x24, 0xd2, 0xb9, 0xf8, 0x73, 0xc6, 0x4a, 0xd0, 0x85, 0x41, 0x76, 0xdb,
    0xef, 0x27, 0xae, 0x96, 0xfd, 0x90, 0x40, 0x9f, 0x4e, 0xe2, 0x02, 0xba, 0x6e, 0x04, 0xd7, 0x34,
    0x5b, 0x55, 0x14, 0x86, 0x65, 0x02, 0xdd, 0x68, 0x8a, 0x06, 0xb2, 0xba, 0x7e, 0xd4, 0xb0, 0x93
  };
  const unsigned char SM4_GCM_AAD[20] = {
    0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
    0xab, 0xad, 0xda, 0xd2
  };
  const unsigned char SM4_GCM_TAG[16] = {
    0xff, 0xa6, 0xc2, 0x3e, 0x97, 0xe6, 0xa7, 0x2b, 0x28, 0xd5, 0x5c, 0x9a, 0xdd, 0x13, 0x2b, 0x1d
  };

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = (size / 16 + 1) * 16;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);

  ret |= SM4_GCM_Encrypt_NIST_SP800_38D((unsigned char *)SM4_GCM_PLAIN, size, cipher, &txtlen, tag, &taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size / 16 + 1) * 16 != txtlen || (memcmp(SM4_GCM_CIPHER, cipher, txtlen) != 0) ||
    (memcmp(SM4_GCM_TAG, tag, taglen) != 0)) {
    ret |= RET_ERR;
  }

  unsigned char plain[txtlen];
  memset(plain, 0x00, txtlen);

  ret |= SM4_GCM_Decrypt_NIST_SP800_38D(cipher, txtlen, plain, &txtlen, tag, taglen,
                            (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen,
                            (unsigned char *)SM4_GCM_AAD, aadlen);
  if ((size != txtlen) || (memcmp(SM4_GCM_PLAIN, plain, txtlen) != 0)) {
    ret |= RET_ERR;
  }
  
  return ret;
}

//SM4分步计算
int test_SM4_CBC_Enc_Pad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_CBC_CIPHER_WITH_PADDING, outb, sizeof(SM4_ECB_CIPHER_WITH_PADDING)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Enc_Pad_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160+16] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
        0x88,0x73,0xE8,0xBB,0xC6,0xD7,0x31,0x3C,0x92,0xA7,0xD1,0x04,0x1B,0xE6,0x9B,0x56,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Enc_Pad_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160+16] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
        0x88,0x73,0xE8,0xBB,0xC6,0xD7,0x31,0x3C,0x92,0xA7,0xD1,0x04,0x1B,0xE6,0x9B,0x56,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Enc_Pad_4(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    
    unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
    
    int ret = RET_OK;
    size_t size = length;
    size_t txtlen = (size/16+1)*16;
    
    unsigned char* data=(unsigned char*)malloc(txtlen * 3);
    if (NULL == data) {
        return -1;
    }
    unsigned char* plain = data;
    random_content(length, plain);
    unsigned char* outb_step = data + length;
    unsigned char* outb_once = data + length + txtlen;
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_in = plain;
    unsigned char *p_outb = outb_step;
    unsigned long sum = 0;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    for(unsigned int i = 0; i < length/256; i++) {
        if(ret)
            goto END;
        ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
        p_in += plain[i] + 1;
        sum += plain[i] + 1;
        p_outb += txtlen;
    }
    if(length > sum) {
        if(ret)
            goto END;
        ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
        p_outb += txtlen;
    }
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);

    if(ret)
        goto END;
    ret |= SM4_CBC_Encrypt((const unsigned char*)plain, size, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
    if(ret || memcmp(outb_once, outb_step, txtlen)) {
        ret |= RET_ERR;
    }
 END:
    free(data);
    return ret;
}

int test_SM4_CBC_Encrypt_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CBC_Enc_Pad_1();
    ret |= test_SM4_CBC_Enc_Pad_2();
    ret |= test_SM4_CBC_Enc_Pad_3();
    ret |= test_SM4_CBC_Enc_Pad_4();
    return ret;
}

int test_SM4_CBC_Dec_Pad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_CBC_CIPHER_WITH_PADDING)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)SM4_CBC_CIPHER_WITH_PADDING, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)SM4_CBC_CIPHER_WITH_PADDING + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_Pad_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160+16] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
        0x88,0x73,0xE8,0xBB,0xC6,0xD7,0x31,0x3C,0x92,0xA7,0xD1,0x04,0x1B,0xE6,0x9B,0x56,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_Pad_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160+16] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
        0x88,0x73,0xE8,0xBB,0xC6,0xD7,0x31,0x3C,0x92,0xA7,0xD1,0x04,0x1B,0xE6,0x9B,0x56,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_Pad_4(void) {
    const unsigned char KEY[16] = {
        0x7f,0x31,0xec,0x36,0x35,0x52,0x64,0x0e,0x56,0x1f,0xe8,0x8f,0xc7,0x35,0x5f,0x08
    };
    const unsigned char IV[16] = {
        0xb4,0x0e,0x0c,0xff,0xc1,0x9a,0x08,0x69,0x24,0xb1,0x0d,0x32,0x0d,0xc1,0x76,0x31
    };
    const unsigned char PLAIN[160+12] = {
        0xe8,0x39,0x2b,0xc8,0xfe,0xe2,0xac,0x11,0xf3,0xf6,0xe4,0xd5,0x52,0x4c,0x8d,0x5b,
        0x1d,0x64,0x4b,0x92,0x3c,0x2a,0x50,0x6b,0x10,0x88,0x09,0x78,0x98,0xd8,0x56,0x36,
        0x52,0x8f,0x6a,0x5b,0xc7,0x72,0x42,0xc6,0xdf,0x1b,0xe0,0x1b,0xde,0x63,0x6d,0x5f,
        0x86,0x6c,0x8a,0x72,0x05,0xba,0xe6,0x6e,0xad,0x5f,0xb7,0x70,0xd6,0xa1,0x36,0x89,
        0xf2,0x71,0xc5,0x70,0xfc,0x94,0x3d,0xaf,0xfe,0xb4,0x60,0xc4,0x7e,0xa3,0xed,0x6c,
        0x27,0x4e,0x96,0x39,0x39,0x8e,0xe1,0x0a,0xcd,0x46,0x85,0x67,0xc4,0x2f,0x04,0x95,
        0x5c,0x79,0xb6,0x02,0xc5,0xd6,0x85,0x64,0xea,0xd9,0x5c,0x09,0xbb,0x6c,0xcd,0x71,
        0x90,0xa4,0xd6,0xcc,0x02,0x1e,0x77,0x0c,0xb8,0x6b,0x81,0xac,0x01,0xf8,0xe4,0x9a,
        0xc5,0xcf,0xf5,0x95,0x40,0x66,0x1b,0x67,0x87,0xb0,0x58,0x4f,0x47,0x83,0xad,0xc3,
        0xf9,0xac,0x15,0xac,0xcb,0xae,0xbf,0xc1,0xa4,0x42,0x7d,0xf2,0x8d,0x0f,0xc4,0xed,
        0xfa,0xf5,0xe5,0x05,0x3e,0x1e,0x26,0xfc,0x74,0x0b,0x9f,0xc8,
    };
    
    const unsigned char CIPHER[160+16] = {
        0x68,0xE6,0x2B,0x8B,0x49,0x81,0x26,0xF6,0x10,0x7F,0x3C,0xBA,0xA0,0xE7,0xCE,0x2F,
        0xFB,0x80,0x47,0x3D,0x83,0xCD,0xA4,0xDA,0xF4,0xE4,0x8E,0x40,0x39,0x19,0x6F,0xAB,
        0xAC,0xF0,0x3F,0x57,0x2F,0xAE,0xD7,0xD9,0x6D,0x86,0xE6,0xD4,0x92,0x39,0x0D,0x42,
        0x0A,0x05,0x0E,0xA2,0x20,0x68,0xD5,0xF6,0xB8,0x23,0xE9,0x88,0x93,0x6F,0xEA,0xDC,
        0x94,0xA2,0xA8,0x2A,0x8B,0x41,0x43,0x33,0x51,0x94,0x6C,0x60,0xC2,0x9D,0x81,0x80,
        0xA9,0x5B,0x69,0x2B,0x7C,0x22,0xA0,0xC3,0x16,0x0B,0xA7,0x3D,0x47,0x68,0x63,0x4B,
        0x5D,0x21,0xCF,0xEF,0x9D,0xDB,0x4E,0x6B,0x8A,0x59,0x40,0x1F,0x35,0x13,0x83,0x86,
        0xC3,0x79,0xEB,0x12,0xBA,0x08,0xFA,0x66,0xB0,0x4D,0xC3,0xA4,0x81,0x0D,0x26,0x9C,
        0x4C,0xF1,0x52,0xD5,0x89,0x5A,0xF0,0x40,0x66,0xA2,0xB5,0xE0,0xD5,0xF8,0xA2,0x5A,
        0x86,0x85,0xA2,0xE3,0xB1,0x64,0xBC,0x3D,0x85,0x5E,0x8C,0x49,0xDD,0x44,0x45,0x68,
        0x2E,0xFE,0xD7,0x16,0x22,0xAF,0x74,0x53,0x53,0x54,0x71,0x37,0xD2,0x37,0x65,0xCD,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1, 16, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1, 62, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62 + 14 + 34, size - (1 + 14 + 1 + 16 + 1 + 62 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_Pad_5(void) {
    const unsigned char KEY[16] = {
        0x7f,0x31,0xec,0x36,0x35,0x52,0x64,0x0e,0x56,0x1f,0xe8,0x8f,0xc7,0x35,0x5f,0x08
    };
    const unsigned char IV[16] = {
        0xb4,0x0e,0x0c,0xff,0xc1,0x9a,0x08,0x69,0x24,0xb1,0x0d,0x32,0x0d,0xc1,0x76,0x31
    };
    
    unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
    
    int ret = RET_OK;
    size_t size = length;
    size_t txtlen = (size/16+1)*16;
    
    unsigned char* data=(unsigned char*)malloc(txtlen * 4);
    if (NULL == data) {
        return -1;
    }
    
    unsigned char* plain = data;
    random_content(length, plain);
    
    unsigned char* cipher = data + length;;
    ret |= SM4_CBC_Encrypt((const unsigned char*)plain, size, cipher, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);

    unsigned char* outb_step = data + length + txtlen;
    unsigned char* outb_once = data + length + txtlen + length;

    tcsm_sm4_cbc_t ctx;
    int no_padding = 0;
    unsigned char *p_in = cipher;
    unsigned char *p_outb = outb_step;
    unsigned long sum = 0;
    size_t tmplen = 0;
    
    if(ret)
        goto END;
    ret |= SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    for(unsigned int i = 0; i < length/256; i++) {
        if(ret)
            goto END;
        ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &tmplen);
        p_in += plain[i] + 1;
        sum += plain[i] + 1;
        p_outb += tmplen;
    }
    if(txtlen > sum) {
        if(ret)
            goto END;
        ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)p_in, txtlen - sum, p_outb, &tmplen);
        p_outb += tmplen;
    }
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &tmplen);
    if(ret)
        goto END;
    
    ret |= SM4_CBC_Decrypt((const unsigned char*)cipher, txtlen, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
    if(ret || (memcmp(outb_once, outb_step, txtlen)) || (memcmp(outb_once, plain, txtlen)) || (txtlen != length)) {
        ret |= RET_ERR;
    }
 END:
    free(data);
    return ret;
}

int test_SM4_CBC_Decrypt_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CBC_Dec_Pad_1();
    ret |= test_SM4_CBC_Dec_Pad_2();
    ret |= test_SM4_CBC_Dec_Pad_3();
    ret |= test_SM4_CBC_Dec_Pad_4();
    ret |= test_SM4_CBC_Dec_Pad_5();
    return ret;
}

int test_SM4_CBC_Enc_NoPad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_CBC_CIPHER, outb, sizeof(SM4_CBC_CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}


int test_SM4_CBC_Enc_NoPad_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, size, outb, &txtlen);
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Enc_NoPad_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Enc_NoPad_4(void) {
  const unsigned char KEY[16] = {
      0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[16] = {
      0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
  };
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
      return -1;
  }
  unsigned char* plain = data;
  random_content(length, plain);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_cbc_t ctx;
  int no_padding = 1;
  unsigned char *p_in = plain;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
 
  ret = SM4_CBC_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
  for(unsigned int i = 0; i < length/256; i++) {
      if(ret)
          goto END;
      ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
      p_in += plain[i] + 1;
      sum += plain[i] + 1;
      p_outb += txtlen;
  }
  if(length > sum) {
      if(ret)
          goto END;
      ret |= SM4_CBC_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
      p_outb += txtlen;
  }
 
  ret |= SM4_CBC_Encrypt_Final(&ctx, p_outb, &txtlen);

  if(ret)
      goto END;
  ret |= SM4_CBC_Encrypt_NoPadding((const unsigned char*)plain, size, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
      ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_CBC_Encrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CBC_Enc_NoPad_1();
    ret |= test_SM4_CBC_Enc_NoPad_2();
    ret |= test_SM4_CBC_Enc_NoPad_3();
    ret |= test_SM4_CBC_Enc_NoPad_4();
    return ret;
}

int test_SM4_CBC_Dec_NoPad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_ECB_CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)SM4_CBC_CIPHER, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)SM4_CBC_CIPHER + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_NoPad_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, size, outb, &txtlen);
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_NoPad_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160] = {
        0x11,0x63,0x44,0xa7,0x10,0x17,0x90,0x50,0x8d,0x8b,0x9e,0x8c,0x0f,0x20,0x67,0xc4,
        0xa0,0xf6,0xc2,0xbb,0xa2,0x15,0x72,0x11,0x21,0x33,0x60,0x8e,0xf6,0xc2,0xd8,0xd1,
        0x95,0x90,0xba,0xa6,0xbd,0xac,0x72,0x09,0xc6,0x26,0x45,0x11,0x85,0xa3,0x69,0x95,
        0xe8,0x3b,0x4d,0x84,0x47,0x63,0x30,0x9b,0xba,0x2e,0x3b,0x61,0x67,0x82,0x9b,0x52,
        0x00,0x60,0x11,0xa3,0x65,0xf5,0x91,0xc4,0x5d,0x21,0xe2,0x48,0x43,0xa0,0x97,0x6c,
        0x92,0x71,0xdf,0x7f,0x7b,0x61,0x6f,0x49,0x3a,0xc4,0x39,0xd8,0xb8,0x6d,0xc9,0xc6,
        0x22,0x39,0xf3,0xb0,0x16,0xcd,0x53,0x11,0x6b,0xc1,0x08,0xcd,0x30,0x07,0x75,0xf2,
        0x21,0xcf,0xef,0xff,0x81,0x31,0x1a,0xa0,0x2b,0xd5,0x68,0xb9,0xa1,0x61,0x86,0x9a,
        0x70,0x10,0xeb,0x97,0xa1,0x5b,0x1e,0x7d,0x30,0x8c,0xa8,0xb7,0x30,0x5e,0xc1,0x52,
        0x5a,0x49,0x04,0xf1,0x56,0x71,0x99,0xa1,0x4f,0xd9,0xa5,0xb6,0xcd,0xd2,0x64,0x9a,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_cbc_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CBC_Dec_NoPad_4(void) {
  const unsigned char KEY[16] = {
      0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[16] = {
      0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
  };
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
      return -1;
  }
  unsigned char* cipher = data;
  random_content(length, cipher);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_cbc_t ctx;
  int no_padding = 1;
  unsigned char *p_in = cipher;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
 
  ret = SM4_CBC_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, no_padding);
  for(unsigned int i = 0; i < length/256; i++) {
      if(ret)
          goto END;
      ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)p_in, cipher[i] + 1, p_outb, &txtlen);
      p_in += cipher[i] + 1;
      sum += cipher[i] + 1;
      p_outb += txtlen;
  }
  if(length > sum) {
      if(ret)
          goto END;
      ret |= SM4_CBC_Decrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
      p_outb += txtlen;
  }
 
  ret |= SM4_CBC_Decrypt_Final(&ctx, p_outb, &txtlen);

  if(ret)
      goto END;
  ret |= SM4_CBC_Decrypt_NoPadding((const unsigned char*)cipher, size, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
      ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_CBC_Decrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CBC_Dec_NoPad_1();
    ret |= test_SM4_CBC_Dec_NoPad_2();
    ret |= test_SM4_CBC_Dec_NoPad_3();
    ret |= test_SM4_CBC_Dec_NoPad_4();
    return ret;
}


int test_SM4_ECB_Enc_Pad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)SM4_KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_ECB_CIPHER_WITH_PADDING, outb, sizeof(SM4_ECB_CIPHER_WITH_PADDING)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_Pad_2(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160+16] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
        0x1C,0xF1,0xB6,0xD0,0x5F,0xA2,0xAC,0x86,0x97,0x9F,0x19,0x0A,0x96,0x5F,0x9E,0x2D
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_Pad_3(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160+16] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
        0x1C,0xF1,0xB6,0xD0,0x5F,0xA2,0xAC,0x86,0x97,0x9F,0x19,0x0A,0x96,0x5F,0x9E,0x2D
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_Pad_4(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    
    unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
    
    int ret = RET_OK;
    size_t size = length;
    size_t txtlen = (size/16+1)*16;
    
    unsigned char* data=(unsigned char*)malloc(txtlen * 3);
    if (NULL == data) {
        return -1;
    }
    unsigned char* plain = data;
    random_content(length, plain);
    unsigned char* outb_step = data + length;
    unsigned char* outb_once = data + length + txtlen;
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_in = plain;
    unsigned char *p_outb = outb_step;
    unsigned long sum = 0;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    for(unsigned int i = 0; i < length/256; i++) {
        if(ret)
            goto END;
        ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
        p_in += plain[i] + 1;
        sum += plain[i] + 1;
        p_outb += txtlen;
    }
    if(length > sum) {
        if(ret)
            goto END;
        ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
        p_outb += txtlen;
    }
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(ret)
        goto END;
    ret |= SM4_ECB_Encrypt((const unsigned char*)plain, size, outb_once, &txtlen, (const unsigned char*)KEY);
    if(ret || memcmp(outb_once, outb_step, txtlen)) {
        ret |= RET_ERR;
    }
END:
    free(data);
    return ret;
}


int test_SM4_ECB_Encrypt_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_ECB_Enc_Pad_1();
    ret |= test_SM4_ECB_Enc_Pad_2();
    ret |= test_SM4_ECB_Enc_Pad_3();
    ret |= test_SM4_ECB_Enc_Pad_4();
    return ret;
}

int test_SM4_ECB_Dec_Pad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_ECB_CIPHER_WITH_PADDING)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)SM4_KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)SM4_ECB_CIPHER_WITH_PADDING, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)SM4_ECB_CIPHER_WITH_PADDING + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_Pad_2(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160+16] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
        0x1C,0xF1,0xB6,0xD0,0x5F,0xA2,0xAC,0x86,0x97,0x9F,0x19,0x0A,0x96,0x5F,0x9E,0x2D
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_Pad_3(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160+16] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
        0x1C,0xF1,0xB6,0xD0,0x5F,0xA2,0xAC,0x86,0x97,0x9F,0x19,0x0A,0x96,0x5F,0x9E,0x2D
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_Pad_4(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160+10] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
        0x8a,0x54,0xf3,0x3d,0x52,0x02,0x5a,0x90,0xbd,0xa6
    };
    
    const unsigned char CIPHER[160+16] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
        0x6B,0x56,0xE3,0x93,0x2F,0xD2,0x25,0xD9,0x0B,0xF3,0x9F,0x8E,0x0F,0x7A,0x49,0xAE,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1, 16, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1, 62, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 14 + 1 + 16 + 1 + 62 + 14 + 34, size - (1 + 14 + 1 + 16 + 1 + 62 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_Pad_5(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    
    unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
    
    int ret = RET_OK;
    size_t size = length;
    size_t txtlen = (size/16+1)*16;
    
    unsigned char* data=(unsigned char*)malloc(txtlen * 4);
    if (NULL == data) {
        return -1;
    }
    
    unsigned char* plain = data;
    random_content(length, plain);
    
    unsigned char* cipher = data + length;;
    ret |= SM4_ECB_Encrypt((const unsigned char*)plain, size, cipher, &txtlen, (const unsigned char*)KEY);

    unsigned char* outb_step = data + length + txtlen;
    unsigned char* outb_once = data + length + txtlen + length;

    tcsm_sm4_ecb_t ctx;
    int no_padding = 0;
    unsigned char *p_in = cipher;
    unsigned char *p_outb = outb_step;
    unsigned long sum = 0;
    size_t tmplen = 0;
    
    if(ret)
        goto END;
    ret |= SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    for(unsigned int i = 0; i < length/256; i++) {
        if(ret)
            goto END;
        ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &tmplen);
        p_in += plain[i] + 1;
        sum += plain[i] + 1;
        p_outb += tmplen;
    }
    if(txtlen > sum) {
        if(ret)
            goto END;
        ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)p_in, txtlen - sum, p_outb, &tmplen);
        p_outb += tmplen;
    }
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &tmplen);
    if(ret)
        goto END;
    
    ret |= SM4_ECB_Decrypt((const unsigned char*)cipher, txtlen, outb_once, &txtlen, (const unsigned char*)KEY);
    if(ret || (memcmp(outb_once, outb_step, txtlen)) || (memcmp(outb_once, plain, txtlen)) || (txtlen != length)) {
        ret |= RET_ERR;
    }
 END:
    free(data);
    return ret;
}

int test_SM4_ECB_Decrypt_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_ECB_Dec_Pad_1();
    ret |= test_SM4_ECB_Dec_Pad_2();
    ret |= test_SM4_ECB_Dec_Pad_3();
    ret |= test_SM4_ECB_Dec_Pad_4();
    ret |= test_SM4_ECB_Dec_Pad_5();
    return ret;
}

int test_SM4_ECB_Enc_NoPad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = (size/16+1)*16;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)SM4_KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_ECB_CIPHER, outb, sizeof(SM4_ECB_CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_NoPad_2(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, size, outb, &txtlen);
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_NoPad_3(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Enc_NoPad_4(void) {
  const unsigned char KEY[16] = {
    0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a,
  };
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
      return -1;
  }
  unsigned char* plain = data;
  random_content(length, plain);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_ecb_t ctx;
  int no_padding = 1;
  unsigned char *p_in = plain;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
 
  ret = SM4_ECB_Encrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
  for(unsigned int i = 0; i < length/256; i++) {
      if(ret)
          goto END;
      ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
      p_in += plain[i] + 1;
      sum += plain[i] + 1;
      p_outb += txtlen;
  }
  if(length > sum) {
      if(ret)
          goto END;
      ret |= SM4_ECB_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
      p_outb += txtlen;
  }
 
  ret |= SM4_ECB_Encrypt_Final(&ctx, p_outb, &txtlen);

  if(ret)
      goto END;
  ret |= SM4_ECB_Encrypt_NoPadding((const unsigned char*)plain, size, outb_once, &txtlen, (const unsigned char*)KEY);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
      ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_ECB_Encrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_ECB_Enc_NoPad_1();
    ret |= test_SM4_ECB_Enc_NoPad_2();
    ret |= test_SM4_ECB_Enc_NoPad_3();
    ret |= test_SM4_ECB_Enc_NoPad_4();
    return ret;
}


int test_SM4_ECB_Dec_NoPad_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_ECB_CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)SM4_KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)SM4_ECB_CIPHER, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)SM4_ECB_CIPHER + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_NoPad_2(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, size, outb, &txtlen);
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_NoPad_3(void) {
    const unsigned char KEY[16] = {
        0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
    };
    const unsigned char PLAIN[160] = {
        0x1a,0x3e,0xdb,0xc0,0x31,0x3f,0x02,0xcb,0xfa,0x2a,0x4d,0x1c,0x2e,0x51,0x97,0x54,
        0x4f,0x69,0xfb,0xd8,0x6e,0x87,0xa6,0x25,0xc9,0xbd,0x72,0xbf,0x74,0xdd,0x60,0x7d,
        0x83,0x94,0x1b,0xa1,0xfa,0x81,0x4a,0xcd,0xe6,0x4f,0x49,0x61,0xb9,0x68,0x77,0x58,
        0xb8,0xbf,0x3a,0x6a,0x37,0xc9,0xed,0x28,0xb5,0xe2,0x6e,0x04,0xff,0xf4,0x8e,0x82,
        0xec,0x9b,0x5a,0x33,0x75,0x11,0x91,0x82,0x83,0x26,0x45,0xa7,0x45,0x31,0x57,0xab,
        0x21,0xc6,0x79,0xfd,0x00,0x59,0x35,0x2b,0xa0,0xb9,0x6a,0x4a,0x8b,0xbd,0x6e,0xd4,
        0x56,0xf1,0x99,0xc6,0x3e,0xa1,0x27,0x85,0x6f,0x4b,0x41,0xed,0xd0,0x48,0x37,0xb0,
        0x8a,0xce,0xb9,0x8f,0x7b,0xe9,0xcb,0xdf,0x8c,0xde,0x66,0x90,0x16,0xd4,0x4e,0xd9,
        0xbf,0xf9,0xd8,0xa6,0x07,0x31,0x6f,0x3a,0x5a,0x22,0x3d,0x33,0x0e,0x11,0x17,0x02,
        0xf3,0x24,0xaa,0x6f,0x45,0x79,0x13,0xe2,0x29,0xb5,0x62,0xd6,0x54,0x9d,0x2e,0xde,
    };
    
    const unsigned char CIPHER[160] = {
        0x5c,0xdc,0x14,0xd4,0x18,0xc3,0x00,0xf2,0x51,0x0d,0x17,0xe4,0x4b,0x1b,0x9a,0xc1,
        0x5c,0x15,0x64,0x22,0x8c,0x47,0x7c,0x09,0x04,0x17,0x48,0xc6,0x85,0xaa,0x24,0xda,
        0xec,0x34,0x23,0x48,0x8c,0x7d,0x75,0x23,0xd6,0x60,0xe3,0x83,0x49,0x68,0xfd,0x2b,
        0xae,0x93,0x3a,0x0c,0x0d,0x71,0x2f,0xf7,0xea,0xef,0x63,0xfa,0xa7,0x52,0xbb,0x46,
        0x69,0x66,0x7c,0xd8,0x8e,0x52,0xe1,0xc6,0x87,0x12,0xc6,0xff,0x11,0xe5,0x27,0x44,
        0x98,0x58,0x15,0xd6,0x2f,0x05,0xdc,0x49,0xcc,0x54,0x23,0x97,0xb6,0x25,0x90,0x0d,
        0x6b,0x57,0x7a,0xd2,0x32,0x6d,0x9e,0xb1,0x93,0x52,0xbd,0xe6,0x1e,0x96,0x0e,0xc4,
        0xd2,0x45,0x7f,0x36,0xed,0x37,0xaa,0x35,0xbd,0x37,0x8e,0xf0,0x79,0xa7,0x87,0x78,
        0x55,0x3d,0xbd,0xfe,0x4d,0x5a,0xa8,0x2c,0x21,0x96,0x4e,0xf4,0x4b,0x75,0x7e,0xd8,
        0xfe,0x5e,0x2d,0x0f,0x19,0x15,0xd4,0xfa,0xc1,0x90,0x96,0xd6,0xf1,0x81,0x1b,0xe0,
    };
    int ret = RET_OK;
    size_t size = sizeof(CIPHER)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ecb_t ctx;
    int no_padding = 1;
    unsigned char *p_outb = outb;
    
    ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_ECB_Dec_NoPad_4(void) {
  const unsigned char KEY[16] = {
    0xe5,0x61,0xbc,0xf7,0xf3,0xf7,0x5e,0x70,0x2c,0xe6,0x76,0x79,0xe8,0xc6,0x80,0x2a
  };
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
      return -1;
  }
  unsigned char* cipher = data;
  random_content(length, cipher);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_ecb_t ctx;
  int no_padding = 1;
  unsigned char *p_in = cipher;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
 
  ret = SM4_ECB_Decrypt_Init(&ctx, (const unsigned char*)KEY, no_padding);
  for(unsigned int i = 0; i < length/256; i++) {
      if(ret)
          goto END;
      ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)p_in, cipher[i] + 1, p_outb, &txtlen);
      p_in += cipher[i] + 1;
      sum += cipher[i] + 1;
      p_outb += txtlen;
  }
  if(length > sum) {
      if(ret)
          goto END;
      ret |= SM4_ECB_Decrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
      p_outb += txtlen;
  }
 
  ret |= SM4_ECB_Decrypt_Final(&ctx, p_outb, &txtlen);

  if(ret)
      goto END;
  ret |= SM4_ECB_Decrypt_NoPadding((const unsigned char*)cipher, size, outb_once, &txtlen, (const unsigned char*)KEY);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
      ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_ECB_Decrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_ECB_Dec_NoPad_1();
    ret |= test_SM4_ECB_Dec_NoPad_2();
    ret |= test_SM4_ECB_Dec_NoPad_3();
    ret |= test_SM4_ECB_Dec_NoPad_4();
    return ret;
}

int test_SM4_CTR_Enc_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ctr_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_CTR_Encrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV);
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)SM4_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Final(&ctx);
    if(memcmp(SM4_CTR_CIPHER, outb, sizeof(SM4_CTR_CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }

 END:
    return ret;
}


int test_SM4_CTR_Enc_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92,0x67
    };
    
    const unsigned char CIPHER[160] = {
        0x49,0x4d,0x4e,0x08,0xef,0xf1,0xe9,0xad,0x19,0xf4,0x67,0xab,0x4d,0x0e,0xb1,0x20,
        0x9f,0xb3,0x3a,0xf0,0x68,0x10,0x2e,0x21,0xb8,0xeb,0x2f,0xe2,0x73,0x80,0xe5,0x9b,
        0x5b,0xf0,0xfa,0x0e,0x26,0x1e,0x62,0x43,0x27,0x5f,0xa4,0x90,0xd8,0x40,0x08,0x25,
        0x43,0x53,0x0a,0x48,0x33,0x7e,0xf2,0x10,0xf3,0x3d,0x52,0xd1,0x57,0x22,0xb2,0xf7,
        0x44,0x9b,0x28,0xb1,0x9d,0x27,0x01,0xec,0x7e,0x80,0x45,0x2e,0xdb,0x4f,0x20,0x87,
        0x42,0x2b,0xd6,0xf0,0x73,0x73,0x7e,0x71,0x48,0x71,0x6c,0x33,0xc8,0xda,0x3e,0x69,
        0x8e,0xe7,0x58,0x69,0x89,0x65,0x2c,0x5e,0x6a,0xa4,0x52,0x43,0x1d,0xf3,0x6c,0x60,
        0x34,0x79,0xa9,0x55,0x12,0xac,0x84,0xa0,0x66,0x1e,0xc4,0x59,0x1d,0xca,0x2c,0x4c,
        0x7b,0xb0,0x7b,0x4d,0x7d,0xb1,0x48,0x76,0xde,0xbb,0x99,0x2c,0xb1,0x59,0x5d,0x3b,
        0x98,0xf1,0xda,0x8b,0x56,0xe9,0x1c,0xfc,0x41,0xb9,0x27,0xe3,0xfa,0x26,0x5a,0x01,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ctr_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_CTR_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Final(&ctx);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CTR_Enc_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160-4] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,
    };
    
    const unsigned char CIPHER[160-4] = {
        0x49,0x4d,0x4e,0x08,0xef,0xf1,0xe9,0xad,0x19,0xf4,0x67,0xab,0x4d,0x0e,0xb1,0x20,
        0x9f,0xb3,0x3a,0xf0,0x68,0x10,0x2e,0x21,0xb8,0xeb,0x2f,0xe2,0x73,0x80,0xe5,0x9b,
        0x5b,0xf0,0xfa,0x0e,0x26,0x1e,0x62,0x43,0x27,0x5f,0xa4,0x90,0xd8,0x40,0x08,0x25,
        0x43,0x53,0x0a,0x48,0x33,0x7e,0xf2,0x10,0xf3,0x3d,0x52,0xd1,0x57,0x22,0xb2,0xf7,
        0x44,0x9b,0x28,0xb1,0x9d,0x27,0x01,0xec,0x7e,0x80,0x45,0x2e,0xdb,0x4f,0x20,0x87,
        0x42,0x2b,0xd6,0xf0,0x73,0x73,0x7e,0x71,0x48,0x71,0x6c,0x33,0xc8,0xda,0x3e,0x69,
        0x8e,0xe7,0x58,0x69,0x89,0x65,0x2c,0x5e,0x6a,0xa4,0x52,0x43,0x1d,0xf3,0x6c,0x60,
        0x34,0x79,0xa9,0x55,0x12,0xac,0x84,0xa0,0x66,0x1e,0xc4,0x59,0x1d,0xca,0x2c,0x4c,
        0x7b,0xb0,0x7b,0x4d,0x7d,0xb1,0x48,0x76,0xde,0xbb,0x99,0x2c,0xb1,0x59,0x5d,0x3b,
        0x98,0xf1,0xda,0x8b,0x56,0xe9,0x1c,0xfc,0x41,0xb9,0x27,0xe3
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ctr_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_CTR_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 64 + 14 + 34, size - (1 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Encrypt_Final(&ctx);
    if(memcmp(CIPHER, outb, sizeof(CIPHER)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CTR_Enc_4(void) {
  const unsigned char KEY[16] = {
    0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[16] = {
    0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
  };
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
    return -1;
  }
  unsigned char* plain = data;
  random_content(length, plain);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_ctr_t ctx;
  unsigned char *p_in = plain;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;

  ret = SM4_CTR_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
  for(unsigned int i = 0; i < length/256; i++) {
    if(ret)
      goto END;
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
    p_in += plain[i] + 1;
    sum += plain[i] + 1;
    p_outb += txtlen;
  }
  if(length > sum) {
    if(ret)
      goto END;
    ret |= SM4_CTR_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
    p_outb += txtlen;
  }
 
  ret |= SM4_CTR_Encrypt_Final(&ctx);

  if(ret)
    goto END;
  ret |= SM4_CTR_Encrypt_NoPadding((const unsigned char*)plain, size, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
    ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_CTR_Encrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CTR_Enc_1();
    ret |= test_SM4_CTR_Enc_2();
    ret |= test_SM4_CTR_Enc_3();
    ret |= test_SM4_CTR_Enc_4();
    return ret;
}

int test_SM4_CTR_Dec_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ctr_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_CTR_Decrypt_Init(&ctx, (const unsigned char*)SM4_KEY, (const unsigned char*)SM4_IV);
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)SM4_CTR_CIPHER, size - 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)SM4_CTR_CIPHER + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Final(&ctx);
    if(memcmp(SM4_PLAIN, outb, sizeof(SM4_PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CTR_Dec_2(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160-1] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,0xad,0x4f,0x92
    };
    
    const unsigned char CIPHER[160-1] = {
        0x49,0x4d,0x4e,0x08,0xef,0xf1,0xe9,0xad,0x19,0xf4,0x67,0xab,0x4d,0x0e,0xb1,0x20,
        0x9f,0xb3,0x3a,0xf0,0x68,0x10,0x2e,0x21,0xb8,0xeb,0x2f,0xe2,0x73,0x80,0xe5,0x9b,
        0x5b,0xf0,0xfa,0x0e,0x26,0x1e,0x62,0x43,0x27,0x5f,0xa4,0x90,0xd8,0x40,0x08,0x25,
        0x43,0x53,0x0a,0x48,0x33,0x7e,0xf2,0x10,0xf3,0x3d,0x52,0xd1,0x57,0x22,0xb2,0xf7,
        0x44,0x9b,0x28,0xb1,0x9d,0x27,0x01,0xec,0x7e,0x80,0x45,0x2e,0xdb,0x4f,0x20,0x87,
        0x42,0x2b,0xd6,0xf0,0x73,0x73,0x7e,0x71,0x48,0x71,0x6c,0x33,0xc8,0xda,0x3e,0x69,
        0x8e,0xe7,0x58,0x69,0x89,0x65,0x2c,0x5e,0x6a,0xa4,0x52,0x43,0x1d,0xf3,0x6c,0x60,
        0x34,0x79,0xa9,0x55,0x12,0xac,0x84,0xa0,0x66,0x1e,0xc4,0x59,0x1d,0xca,0x2c,0x4c,
        0x7b,0xb0,0x7b,0x4d,0x7d,0xb1,0x48,0x76,0xde,0xbb,0x99,0x2c,0xb1,0x59,0x5d,0x3b,
        0x98,0xf1,0xda,0x8b,0x56,0xe9,0x1c,0xfc,0x41,0xb9,0x27,0xe3,0xfa,0x26,0x5a,
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    unsigned char *p_outb = outb;
    
    tcsm_sm4_ctr_t ctx;
    
    ret = SM4_CTR_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, size, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Final(&ctx);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CTR_Dec_3(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[16] = {
        0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
    };
    const unsigned char PLAIN[160-4] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,
    };
    
    const unsigned char CIPHER[160-4] = {
        0x49,0x4d,0x4e,0x08,0xef,0xf1,0xe9,0xad,0x19,0xf4,0x67,0xab,0x4d,0x0e,0xb1,0x20,
        0x9f,0xb3,0x3a,0xf0,0x68,0x10,0x2e,0x21,0xb8,0xeb,0x2f,0xe2,0x73,0x80,0xe5,0x9b,
        0x5b,0xf0,0xfa,0x0e,0x26,0x1e,0x62,0x43,0x27,0x5f,0xa4,0x90,0xd8,0x40,0x08,0x25,
        0x43,0x53,0x0a,0x48,0x33,0x7e,0xf2,0x10,0xf3,0x3d,0x52,0xd1,0x57,0x22,0xb2,0xf7,
        0x44,0x9b,0x28,0xb1,0x9d,0x27,0x01,0xec,0x7e,0x80,0x45,0x2e,0xdb,0x4f,0x20,0x87,
        0x42,0x2b,0xd6,0xf0,0x73,0x73,0x7e,0x71,0x48,0x71,0x6c,0x33,0xc8,0xda,0x3e,0x69,
        0x8e,0xe7,0x58,0x69,0x89,0x65,0x2c,0x5e,0x6a,0xa4,0x52,0x43,0x1d,0xf3,0x6c,0x60,
        0x34,0x79,0xa9,0x55,0x12,0xac,0x84,0xa0,0x66,0x1e,0xc4,0x59,0x1d,0xca,0x2c,0x4c,
        0x7b,0xb0,0x7b,0x4d,0x7d,0xb1,0x48,0x76,0xde,0xbb,0x99,0x2c,0xb1,0x59,0x5d,0x3b,
        0x98,0xf1,0xda,0x8b,0x56,0xe9,0x1c,0xfc,0x41,0xb9,0x27,0xe3
    };
    int ret = RET_OK;
    size_t size = sizeof(PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    
    tcsm_sm4_ctr_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_CTR_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
    
    for(int i = 0; i < 15; i++) {
        ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + i, 1, p_outb, &txtlen);
        p_outb += txtlen;
    }
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 15, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 15 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 15 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 15 + 64 + 14 + 34, size - (15 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_CTR_Decrypt_Final(&ctx);
    if(memcmp(PLAIN, outb, sizeof(PLAIN)/sizeof(unsigned char))) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_CTR_Dec_4(void) {
  const unsigned char KEY[16] = {
      0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[16] = {
      0x6e,0x69,0x8b,0xa8,0x6b,0x64,0xbb,0x43,0xf8,0xec,0x82,0x4c,0x8f,0xc6,0x32,0x65,
  };
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
      return -1;
  }
  unsigned char* cipher = data;
  random_content(length, cipher);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_ctr_t ctx;
  unsigned char *p_in = cipher;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
 
  ret = SM4_CTR_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV);
  for(unsigned int i = 0; i < length/256; i++) {
      if(ret)
          goto END;
      ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)p_in, cipher[i] + 1, p_outb, &txtlen);
      p_in += cipher[i] + 1;
      sum += cipher[i] + 1;
      p_outb += txtlen;
  }
  if(length > sum) {
      if(ret)
          goto END;
      ret |= SM4_CTR_Decrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
      p_outb += txtlen;
  }
 
  ret |= SM4_CTR_Decrypt_Final(&ctx);

  if(ret)
      goto END;
  ret |= SM4_CTR_Decrypt_NoPadding((const unsigned char*)cipher, size, outb_once, &txtlen, (const unsigned char*)KEY, (const unsigned char*)IV);
  if(ret || memcmp(outb_once, outb_step, txtlen) || (txtlen != length)) {
      ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}


int test_SM4_CTR_Decrypt_NoPadding_Steps() {
    int ret = RET_OK;
    ret |= test_SM4_CTR_Dec_1();
    ret |= test_SM4_CTR_Dec_2();
    ret |= test_SM4_CTR_Dec_3();
    ret |= test_SM4_CTR_Dec_4();
    return ret;
}

int test_SM4_GCM_Enc_1(void) {
    int ret = RET_OK;
    size_t size = sizeof(SM4_GCM_TEST_PLAIN)/sizeof(unsigned char);
    size_t txtlen = size;
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    size_t taglen = 16;
    unsigned char tag[taglen];
    memset(tag, 0x00, taglen);

    tcsm_sm4_gcm_t ctx;
    unsigned char *p_outb = outb;
    ret = SM4_GCM_Encrypt_Init(&ctx, (const unsigned char*)SM4_GCM_TEST_KEY, (const unsigned char*)SM4_GCM_TEST_IV, 8, (const unsigned char*)SM4_GCM_TEST_AAD, 16);

    ret = SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)SM4_GCM_TEST_PLAIN, size - 4, p_outb, &txtlen);
    p_outb += txtlen;

    ret = SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)SM4_GCM_TEST_PLAIN + size - 4, 4, p_outb, &txtlen);
    p_outb += txtlen;

    ret |= SM4_GCM_Encrypt_Final(&ctx, tag, taglen);
    if (memcmp(SM4_GCM_TEST_CIPHER_NOPADDING, outb, size) != 0 || memcmp(SM4_GCM_TEST_TAG_NOPADDING, tag, taglen) != 0) {
        ret |= RET_ERR;
    }
 END:
    return ret;
}

int test_SM4_GCM_Enc_2(void) {
    const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH]={
        0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08
    };
    const unsigned char SM4_GCM_IV[60]={
        0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
        0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
        0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
        0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
    };
    const unsigned char SM4_GCM_PLAIN[60]={
        0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
        0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
        0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
        0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39
    };
    const unsigned char SM4_GCM_CIPHER[64]={
        0x9a,0x05,0xc6,0x8e,0x20,0x8a,0x75,0x51,0x31,0x51,0x7d,0x0a,0xe2,0xf2,0xeb,0x82,
        0x1f,0x4b,0x14,0x12,0x24,0xd2,0xb9,0xf8,0x73,0xc6,0x4a,0xd0,0x85,0x41,0x76,0xdb,
        0xef,0x27,0xae,0x96,0xfd,0x90,0x40,0x9f,0x4e,0xe2,0x02,0xba,0x6e,0x04,0xd7,0x34,
        0x5b,0x55,0x14,0x86,0x65,0x02,0xdd,0x68,0x8a,0x06,0xb2,0xba
    };
    const unsigned char SM4_GCM_AAD[20]={
        0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
        0xab,0xad,0xda,0xd2
    };
    const unsigned char SM4_GCM_TAG[16]={
        0x4f,0x78,0xdf,0x5d,0x96,0xdf,0x6d,0xd6,0x4e,0x8c,0xd8,0x25,0x1c,0xc6,0x7d,0x31
    };

    unsigned char tag[16] = {0};
    size_t taglen = 16;

    int ret = RET_OK;
    size_t ivlen = 60;
    size_t aadlen = 20;
    size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
    size_t txtlen = size;

    unsigned char cipher[txtlen];
    memset(cipher, 0x00, txtlen);
    tcsm_sm4_gcm_t ctx;
    
    ret |= SM4_GCM_Encrypt_Init(&ctx, (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen, (const unsigned char*)SM4_GCM_AAD, aadlen);

    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)SM4_GCM_PLAIN, size, cipher, &txtlen);
    
    ret |= SM4_GCM_Encrypt_Final(&ctx, tag, taglen);
    if (memcmp(SM4_GCM_CIPHER, cipher, size) != 0 || memcmp(SM4_GCM_TAG, tag, taglen) != 0) {
      ret |= RET_ERR;
    }
    return ret;
}

int test_SM4_GCM_Enc_3(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH]={
      0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08
  };
  const unsigned char SM4_GCM_IV[60]={
      0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
      0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
      0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
      0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60]={
      0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
      0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
      0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
      0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39
  };
  const unsigned char SM4_GCM_CIPHER[60]={
      0x9a,0x05,0xc6,0x8e,0x20,0x8a,0x75,0x51,0x31,0x51,0x7d,0x0a,0xe2,0xf2,0xeb,0x82,
      0x1f,0x4b,0x14,0x12,0x24,0xd2,0xb9,0xf8,0x73,0xc6,0x4a,0xd0,0x85,0x41,0x76,0xdb,
      0xef,0x27,0xae,0x96,0xfd,0x90,0x40,0x9f,0x4e,0xe2,0x02,0xba,0x6e,0x04,0xd7,0x34,
      0x5b,0x55,0x14,0x86,0x65,0x02,0xdd,0x68,0x8a,0x06,0xb2,0xba
  };
  const unsigned char SM4_GCM_AAD[20]={
      0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
      0xab,0xad,0xda,0xd2
  };
  const unsigned char SM4_GCM_TAG[16]={
      0x4f,0x78,0xdf,0x5d,0x96,0xdf,0x6d,0xd6,0x4e,0x8c,0xd8,0x25,0x1c,0xc6,0x7d,0x31
  };

  unsigned char tag[16] = {0};
  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_PLAIN) / sizeof(unsigned char);
  size_t txtlen = size;

  unsigned char cipher[txtlen];
  memset(cipher, 0x00, txtlen);
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_outb = cipher;
  ret = SM4_GCM_Encrypt_Init(&ctx, (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen, (const unsigned char*)SM4_GCM_AAD, aadlen);

  ret = SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)SM4_GCM_PLAIN, size - 4, p_outb, &txtlen);
  p_outb += txtlen;

  ret = SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)SM4_GCM_PLAIN + size - 4, 4, p_outb, &txtlen);
  p_outb += txtlen;

  ret |= SM4_GCM_Encrypt_Final(&ctx, tag, taglen);
  if (memcmp(SM4_GCM_CIPHER, cipher, size) != 0 || memcmp(SM4_GCM_TAG, tag, taglen) != 0) {
    ret |= RET_ERR;
  }
  return ret;
}

int test_SM4_GCM_Enc_4(void) {
    const unsigned char KEY[16] = {
        0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
    };
    const unsigned char IV[60] = {
        0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
        0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
        0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
        0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
    };
    const unsigned char PLAIN[160-4] = {
        0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
        0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
        0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
        0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
        0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
        0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
        0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
        0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
        0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
        0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,
    };
    const unsigned char CIPHER[160-4] = {
        0x88,0x67,0x18,0xaf,0xed,0xc1,0x91,0xe6,0x2e,0x91,0x0c,0xb9,0xe9,0x56,0x1a,0x88,
        0xcb,0x38,0x07,0xfc,0xce,0xc9,0xb4,0x11,0x19,0xe6,0xb2,0xc1,0x55,0x58,0x0c,0xa6,
        0xa0,0x4f,0x8d,0x4b,0x28,0x22,0x66,0xff,0x90,0xc5,0x2c,0x6f,0x1d,0xf0,0xa6,0x13,
        0x49,0x19,0xb2,0x76,0xba,0xc8,0xed,0x12,0x4d,0xc7,0x3a,0xc8,0x6b,0x98,0x74,0xc6,
        0x68,0xcc,0x99,0x2f,0xc1,0x76,0x67,0x1b,0x98,0x8b,0x75,0x66,0x9e,0xc8,0xa0,0x38,
        0x31,0x2e,0x98,0x5a,0x34,0x66,0x57,0xc6,0xf0,0x52,0xd9,0x15,0x3a,0x51,0x82,0x78,
        0x9a,0xf1,0x23,0xee,0x9c,0xb6,0x89,0x23,0xf7,0xa0,0xce,0x3a,0x47,0x24,0x71,0x29,
        0xd9,0x46,0x0e,0xa0,0x9f,0x41,0x81,0x55,0x51,0x2f,0x05,0x51,0xa0,0x69,0xf0,0x62,
        0x09,0xcc,0x09,0x67,0x5b,0x37,0xc7,0x95,0xa5,0xb1,0x1d,0x46,0xc7,0x4e,0x19,0xed,
        0xf7,0xe8,0x69,0x89,0x92,0x8b,0xdd,0xfa,0x3d,0x54,0x0d,0x7b,
    };
    const unsigned char AAD[20]={
        0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
        0xab,0xad,0xda,0xd2
    };
    const unsigned char TAG[16]={
        0x4b,0xb3,0xa0,0x96,0x53,0x4e,0x03,0xe3,0xad,0x04,0x63,0x1a,0xa2,0xac,0xbe,0xd3
    };
    
    unsigned char tag[16] = {0};
    size_t taglen = 16;

    int ret = RET_OK;
    size_t ivlen = 60;
    size_t aadlen = 20;
    size_t size = sizeof(PLAIN) / sizeof(unsigned char);
    size_t txtlen = size;
    
    unsigned char outb[txtlen];
    memset(outb, 0x00, txtlen);
    tcsm_sm4_gcm_t ctx;
    unsigned char *p_outb = outb;
    
    ret = SM4_GCM_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 1, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 1 + 1 + 1, 1, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 4, 64, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 4 + 64, 14, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 4 + 64 + 14, 34, p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)PLAIN + 4 + 64 + 14 + 34, size - (4 + 64 + 14 + 34), p_outb, &txtlen);
    p_outb += txtlen;
    
    ret |= SM4_GCM_Encrypt_Final(&ctx, tag, taglen);
    if (memcmp(CIPHER, outb, size) != 0 || memcmp(TAG, tag, taglen) != 0) {
      ret |= RET_ERR;
    }
    return ret;
}

int test_SM4_GCM_Enc_5(void) {
  const unsigned char KEY[16] = {
      0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[60] = {
      0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
      0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
      0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
      0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char AAD[20] = {
      0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
      0xab,0xad,0xda,0xd2
  };
  unsigned char tag_step[16] = {0};
  unsigned char tag_once[16] = {0};
  size_t taglen = 16;
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 3);
  if (NULL == data) {
    return -1;
  }
  unsigned char* plain = data;
  random_content(length, plain);
  unsigned char* outb_step = data + length;
  unsigned char* outb_once = data + length + length;
 
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_in = plain;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
    
  ret = SM4_GCM_Encrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  for(unsigned int i = 0; i < length/256; i++) {
    if(ret)
      goto END;
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
    p_in += plain[i] + 1;
    sum += plain[i] + 1;
    p_outb += txtlen;
  }
  if(length > sum) {
    if(ret)
      goto END;
    ret |= SM4_GCM_Encrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
    p_outb += txtlen;
  }

  ret |= SM4_GCM_Encrypt_Final(&ctx, tag_step, taglen);

  if(ret)
    goto END;
  ret |= SM4_GCM_Encrypt_NoPadding_NIST_SP800_38D((const unsigned char*)plain, size, outb_once, &txtlen, tag_once, &taglen, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  if(ret || memcmp(outb_once, outb_step, txtlen) || memcmp(tag_once, tag_step, taglen) ||(txtlen != length) ||(16 != taglen)) {
    ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_GCM_Encrypt_NoPadding_Steps() {
  int ret = RET_OK;
  ret |= test_SM4_GCM_Enc_1();
  ret |= test_SM4_GCM_Enc_2();
  ret |= test_SM4_GCM_Enc_3();
  ret |= test_SM4_GCM_Enc_4();
  ret |= test_SM4_GCM_Enc_5();
  return ret;
}

int test_SM4_GCM_Dec_1(void) {
  int ret = RET_OK;
  size_t taglen = 16;
  
  size_t size = sizeof(SM4_GCM_TEST_CIPHER_NOPADDING)/sizeof(unsigned char);
  size_t txtlen = size;
  unsigned char outb[txtlen];
  memset(outb, 0x00, txtlen);
  
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_outb = outb;
  
  ret = SM4_GCM_Decrypt_Init(&ctx, (const unsigned char*)SM4_GCM_TEST_KEY, (const unsigned char*)SM4_GCM_TEST_IV, 8, (const unsigned char*)SM4_GCM_TEST_AAD, 16);
  ret = SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)SM4_GCM_TEST_CIPHER_NOPADDING, size - 4, p_outb, &txtlen);
  p_outb += txtlen;
  ret = SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)SM4_GCM_TEST_CIPHER_NOPADDING + size - 4, 4, p_outb, &txtlen);
  p_outb += txtlen;
  ret |= SM4_GCM_Decrypt_Final(&ctx, SM4_GCM_TEST_TAG_NOPADDING, taglen);
  if ((0 != ret) || (0 != memcmp(SM4_GCM_TEST_PLAIN, outb, size))) {
      ret |= RET_ERR;
  }
  return ret;
}

int test_SM4_GCM_Dec_2(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH]={
    0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08
  };
  const unsigned char SM4_GCM_IV[60]={
    0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
    0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
    0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
    0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60]={
    0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
    0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
    0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
    0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39
  };
  const unsigned char SM4_GCM_CIPHER[64-4]={
    0x9a,0x05,0xc6,0x8e,0x20,0x8a,0x75,0x51,0x31,0x51,0x7d,0x0a,0xe2,0xf2,0xeb,0x82,
    0x1f,0x4b,0x14,0x12,0x24,0xd2,0xb9,0xf8,0x73,0xc6,0x4a,0xd0,0x85,0x41,0x76,0xdb,
    0xef,0x27,0xae,0x96,0xfd,0x90,0x40,0x9f,0x4e,0xe2,0x02,0xba,0x6e,0x04,0xd7,0x34,
    0x5b,0x55,0x14,0x86,0x65,0x02,0xdd,0x68,0x8a,0x06,0xb2,0xba
  };
  const unsigned char SM4_GCM_AAD[20]={
    0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
    0xab,0xad,0xda,0xd2
  };
  const unsigned char SM4_GCM_TAG[16]={
    0x4f,0x78,0xdf,0x5d,0x96,0xdf,0x6d,0xd6,0x4e,0x8c,0xd8,0x25,0x1c,0xc6,0x7d,0x31
  };

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t taglen = 16;
  size_t size = sizeof(SM4_GCM_CIPHER) / sizeof(unsigned char);
  size_t txtlen = size;
  
  unsigned char outb[txtlen];
  memset(outb, 0x00, txtlen);
  tcsm_sm4_gcm_t ctx;
  
  ret |= SM4_GCM_Decrypt_Init(&ctx, (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen, (const unsigned char*)SM4_GCM_AAD, aadlen);
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)SM4_GCM_CIPHER, size, outb, &txtlen);
  
  ret |= SM4_GCM_Decrypt_Final(&ctx, SM4_GCM_TAG, taglen);
  if ((0 != ret) || (0 != memcmp(SM4_GCM_PLAIN, outb, size))) {
    ret |= RET_ERR;
  }
  return ret;
}

int test_SM4_GCM_Dec_3(void) {
  const unsigned char SM4_GCM_KEY[SM4_KEYBYTE_LENGTH]={
    0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08
  };
  const unsigned char SM4_GCM_IV[60]={
    0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
    0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
    0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
    0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char SM4_GCM_PLAIN[60]={
    0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
    0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
    0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
    0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39
  };
  const unsigned char SM4_GCM_CIPHER[60]={
    0x9a,0x05,0xc6,0x8e,0x20,0x8a,0x75,0x51,0x31,0x51,0x7d,0x0a,0xe2,0xf2,0xeb,0x82,
    0x1f,0x4b,0x14,0x12,0x24,0xd2,0xb9,0xf8,0x73,0xc6,0x4a,0xd0,0x85,0x41,0x76,0xdb,
    0xef,0x27,0xae,0x96,0xfd,0x90,0x40,0x9f,0x4e,0xe2,0x02,0xba,0x6e,0x04,0xd7,0x34,
    0x5b,0x55,0x14,0x86,0x65,0x02,0xdd,0x68,0x8a,0x06,0xb2,0xba
  };
  const unsigned char SM4_GCM_AAD[20]={
    0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
    0xab,0xad,0xda,0xd2
  };
  const unsigned char SM4_GCM_TAG[16]={
    0x4f,0x78,0xdf,0x5d,0x96,0xdf,0x6d,0xd6,0x4e,0x8c,0xd8,0x25,0x1c,0xc6,0x7d,0x31
  };

  size_t taglen = 16;

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = sizeof(SM4_GCM_CIPHER) / sizeof(unsigned char);
  size_t txtlen = size;
    
  unsigned char outb[txtlen];
  memset(outb, 0x00, txtlen);
    
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_outb = outb;
    
  ret = SM4_GCM_Decrypt_Init(&ctx, (const unsigned char*)SM4_GCM_KEY, (const unsigned char*)SM4_GCM_IV, ivlen, (const unsigned char*)SM4_GCM_AAD, aadlen);

  ret = SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)SM4_GCM_CIPHER, size - 4, p_outb, &txtlen);
  p_outb += txtlen;

  ret = SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)SM4_GCM_CIPHER + size - 4, 4, p_outb, &txtlen);
  p_outb += txtlen;

  ret |= SM4_GCM_Decrypt_Final(&ctx, SM4_GCM_TAG, taglen);
  if ((0 != ret) || (0 != memcmp(SM4_GCM_PLAIN, outb, size))) {
      ret |= RET_ERR;
  }
  return ret;
}

int test_SM4_GCM_Dec_4(void) {
  const unsigned char KEY[16] = {
    0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[60] = {
    0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
    0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
    0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
    0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char PLAIN[160-4] = {
    0xa2,0x94,0xaa,0x71,0xa9,0xac,0x5f,0xec,0xc6,0x7e,0xa7,0xef,0x87,0x03,0xfb,0x8e,
    0xd7,0xbf,0xca,0x88,0x34,0xf4,0x03,0x46,0x95,0xc3,0x7e,0x92,0xcd,0x8f,0x12,0xb8,
    0x0b,0x9c,0xea,0x52,0x72,0x3c,0xa7,0xa0,0xb2,0x55,0xa3,0x35,0x12,0x1a,0xdb,0xe1,
    0x40,0xc7,0x09,0x1b,0xb0,0x84,0x4b,0x49,0x81,0xe8,0x7a,0xd8,0x58,0xa6,0xf2,0xbc,
    0x75,0xf2,0xdb,0xe4,0x3b,0xcc,0xef,0xa3,0x9d,0x7a,0x9f,0x7b,0x9e,0xe3,0xbb,0xe6,
    0xa9,0xce,0xfa,0xad,0x79,0x14,0xe1,0xfe,0x6c,0xbf,0x76,0x1e,0xe4,0x6f,0xd2,0x0f,
    0x90,0xf9,0x1a,0x76,0xb6,0x5c,0x85,0xa6,0x3b,0x51,0x9a,0xc0,0x29,0xfa,0xe9,0xeb,
    0xc4,0x24,0x3a,0x8e,0x42,0x55,0x29,0x00,0x57,0xe3,0x71,0x63,0x6f,0x86,0xb2,0x14,
    0xf9,0x4f,0x59,0x57,0x7f,0x9d,0xcd,0x5b,0x26,0x76,0x96,0x06,0xb5,0x11,0xc9,0x3d,
    0x2e,0x2c,0x79,0x20,0xbd,0xe5,0x71,0x03,0xf5,0xba,0x6d,0x5b,
  };
  const unsigned char CIPHER[160-4] = {
    0x88,0x67,0x18,0xaf,0xed,0xc1,0x91,0xe6,0x2e,0x91,0x0c,0xb9,0xe9,0x56,0x1a,0x88,
    0xcb,0x38,0x07,0xfc,0xce,0xc9,0xb4,0x11,0x19,0xe6,0xb2,0xc1,0x55,0x58,0x0c,0xa6,
    0xa0,0x4f,0x8d,0x4b,0x28,0x22,0x66,0xff,0x90,0xc5,0x2c,0x6f,0x1d,0xf0,0xa6,0x13,
    0x49,0x19,0xb2,0x76,0xba,0xc8,0xed,0x12,0x4d,0xc7,0x3a,0xc8,0x6b,0x98,0x74,0xc6,
    0x68,0xcc,0x99,0x2f,0xc1,0x76,0x67,0x1b,0x98,0x8b,0x75,0x66,0x9e,0xc8,0xa0,0x38,
    0x31,0x2e,0x98,0x5a,0x34,0x66,0x57,0xc6,0xf0,0x52,0xd9,0x15,0x3a,0x51,0x82,0x78,
    0x9a,0xf1,0x23,0xee,0x9c,0xb6,0x89,0x23,0xf7,0xa0,0xce,0x3a,0x47,0x24,0x71,0x29,
    0xd9,0x46,0x0e,0xa0,0x9f,0x41,0x81,0x55,0x51,0x2f,0x05,0x51,0xa0,0x69,0xf0,0x62,
    0x09,0xcc,0x09,0x67,0x5b,0x37,0xc7,0x95,0xa5,0xb1,0x1d,0x46,0xc7,0x4e,0x19,0xed,
    0xf7,0xe8,0x69,0x89,0x92,0x8b,0xdd,0xfa,0x3d,0x54,0x0d,0x7b,
  };
  const unsigned char AAD[20]={
    0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
    0xab,0xad,0xda,0xd2
  };
  const unsigned char TAG[16]={
    0x4b,0xb3,0xa0,0x96,0x53,0x4e,0x03,0xe3,0xad,0x04,0x63,0x1a,0xa2,0xac,0xbe,0xd3
  };

  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t taglen = 16;
  size_t size = sizeof(CIPHER) / sizeof(unsigned char);
  size_t txtlen = size;
  
  unsigned char outb[txtlen];
  memset(outb, 0x00, txtlen);
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_outb = outb;
  
  ret = SM4_GCM_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER, 1, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1, 1, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 1, 1, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 1 + 1 + 1, 1, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 4, 64, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 4 + 64, 14, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 4 + 64 + 14, 34, p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)CIPHER + 4 + 64 + 14 + 34, size - (4 + 64 + 14 + 34), p_outb, &txtlen);
  p_outb += txtlen;
  
  ret |= SM4_GCM_Decrypt_Final(&ctx, TAG, taglen);
  if ((0 != ret) || (0 != memcmp(PLAIN, outb, size))) {
    ret |= RET_ERR;
  }
  return ret;
}

int test_SM4_GCM_Dec_5(void) {
  const unsigned char KEY[16] = {
    0x39,0x3e,0x6b,0xdf,0x2e,0x1c,0x17,0xe9,0xdb,0x59,0xab,0xa9,0x49,0x3a,0x1b,0x8a,
  };
  const unsigned char IV[60] = {
    0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
    0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
    0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
    0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,0xa6,0x37,0xb3,0x9b
  };
  const unsigned char AAD[20]={
    0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
    0xab,0xad,0xda,0xd2
  };
  unsigned char TAG[16] = {0};
  size_t taglen = 16;
 
  unsigned long length = sizeof(unsigned char) * 1024 * 1024 * 4;
 
  int ret = RET_OK;
  size_t ivlen = 60;
  size_t aadlen = 20;
  size_t size = length;
  size_t txtlen = size;
 
  unsigned char* data=(unsigned char*)malloc(length * 4);
  if (NULL == data) {
    return -1;
  }
  unsigned char* plain = data;
  random_content(length, plain);
  unsigned char* cipher = data + length;
  unsigned char* outb_step = data + length + length;
  unsigned char* outb_once = data + length + length + length;
 
  tcsm_sm4_gcm_t ctx;
  unsigned char *p_in = cipher;
  unsigned char *p_outb = outb_step;
  unsigned long sum = 0;
  ret |= SM4_GCM_Encrypt_NoPadding_NIST_SP800_38D((const unsigned char*)plain, size, cipher, &txtlen, TAG, &taglen, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  if(ret ||(txtlen != size) ||(16 != taglen)) {
    ret |= RET_ERR;
    goto END;
  }
  ret = SM4_GCM_Decrypt_Init(&ctx, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  for(unsigned int i = 0; i < length/256; i++) {
    if(ret)
      goto END;
    ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)p_in, plain[i] + 1, p_outb, &txtlen);
    p_in += plain[i] + 1;
    sum += plain[i] + 1;
    p_outb += txtlen;
  }
  if(length > sum) {
    if(ret)
      goto END;
    ret |= SM4_GCM_Decrypt_Update(&ctx, (const unsigned char*)p_in, length - sum, p_outb, &txtlen);
    p_outb += txtlen;
  }

  ret |= SM4_GCM_Decrypt_Final(&ctx, TAG, taglen);

  if(ret)
    goto END;
  ret |= SM4_GCM_Decrypt_NoPadding_NIST_SP800_38D((const unsigned char*)cipher, size, outb_once, &txtlen, TAG, taglen, (const unsigned char*)KEY, (const unsigned char*)IV, ivlen, (const unsigned char*)AAD, aadlen);
  if(ret || memcmp(outb_once, outb_step, txtlen) ||(txtlen != length)) {
    ret |= RET_ERR;
  }
END:
  free(data);
  return ret;
}

int test_SM4_GCM_Decrypt_NoPadding_Steps() {
  int ret = RET_OK;
  ret |= test_SM4_GCM_Dec_1();
  ret |= test_SM4_GCM_Dec_2();
  ret |= test_SM4_GCM_Dec_3();
  ret |= test_SM4_GCM_Dec_4();
  ret |= test_SM4_GCM_Dec_5();
  return ret;
}

int test_SM2DecryptWithMode() {
    int ret = RET_OK;
    unsigned char outbuf[256] = {0x00};
    size_t outlen = 256;
    sm2_ctx_t pctx;
    size_t cipher_len = strlen(SM2_CIPHERTXT_NOASN1)/2;
    unsigned char bytecipher[cipher_len];

    tc_hex2bin(SM2_CIPHERTXT_NOASN1, bytecipher);
    SM2InitCtx(&pctx);
    if(SM2DecryptWithMode(&pctx, (const unsigned char*)bytecipher, cipher_len, 
        (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), outbuf, &outlen, SM2CipherMode_C1C3C2) != 0) {
        ret |= RET_ERR;
        goto END;
    } else {
        //compare result
        if(strlen(SM2_PLAINTXT) == outlen && !memcmp(SM2_PLAINTXT, outbuf, outlen)) {
            ret = RET_OK;
        } else {
            ret |= RET_ERR;
        }
    }
END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM2EncryptWithMode() {
    int ret = RET_OK;
    size_t plainlen = strlen(SM2_PLAINTXT);
    size_t plainlen2 = plainlen;
    size_t outlen = plainlen+220;
    unsigned char outbuf[outlen];
    unsigned char plaintxt[256];
    sm2_ctx_t pctx;
    SM2InitCtx(&pctx);
    memset(outbuf, 0x00, outlen);
    memset(plaintxt, 0x00, 256);

    if(SM2EncryptWithMode(&pctx, (const unsigned char*)SM2_PLAINTXT, plainlen, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), outbuf, &outlen, SM2CipherMode_C1C3C2) != 0) {
        ret = RET_ERR;
        goto END;
    }

    //因为随机数，每次加密的结果是不同的，所以用解密来验证.
    if(SM2DecryptWithMode(&pctx, (const unsigned char*)outbuf, outlen, (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), plaintxt, &plainlen, SM2CipherMode_C1C3C2) != 0) {
        ret |= RET_ERR;
        goto END;
    } else {
        //compare result
        char tmpb[plainlen2];
        memcpy(tmpb, SM2_PLAINTXT, plainlen2);
        if(plainlen2 == plainlen && !memcmp(tmpb, plaintxt, plainlen2)) {
            ret = RET_OK;
        } else {
            ret |= RET_ERR;
        }
    }
END:
    SM2FreeCtx(&pctx);
    return ret;
}

int test_SM2VerifyWithMode() {
    int ret = RET_OK;
    // size_t outlen = 256;
    // char outbuf[outlen];
    sm2_ctx_t pctx;
    size_t sig_len = strlen(Sm2_SIGHEX_NOASN1)/2;
    unsigned char* bytessig = (unsigned char*)malloc(sig_len);

    tc_hex2bin(Sm2_SIGHEX_NOASN1, bytessig);

    SM2InitCtx(&pctx);
    // memset(outbuf, 0x00, outlen);

    if(SM2VerifyWithMode(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                                    (const unsigned char*)bytessig, sig_len, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), SM2SignMode_RS) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    if(bytessig != NULL) {
        free(bytessig);
    }
    SM2FreeCtx(&pctx);
    return ret;
}
int test_SM2SignWithMode() {
    int ret = RET_OK;
    size_t outlen = 256;
    unsigned char outbuf[outlen];
    sm2_ctx_t pctx;

    SM2InitCtx(&pctx);
    memset(outbuf, 0x00, outlen);

    if(SM2SignWithMode(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                    (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), (const char*)SM2_PRIKEY, strlen(SM2_PRIKEY), 
                    outbuf, &outlen, SM2SignMode_RS) != 0) {
        ret |= RET_ERR;
        goto END;
    }
    //由于随机数的问题，用verify验证
    if(SM2VerifyWithMode(&pctx, (const unsigned char*)SM2_SIG_MSG, strlen(SM2_SIG_MSG), (const char*)SM2_SIG_ID, strlen(SM2_SIG_ID), 
                                    (const unsigned char*)outbuf, outlen, (const char*)SM2_PUBKEY, strlen(SM2_PUBKEY), SM2SignMode_RS) != 0) {
        ret |= RET_ERR;
        goto END;
    }

END:
    SM2FreeCtx(&pctx);
    return ret;
}

const static char* INTERFACE_METHODS_NAME[]
    = {"Version","SM2CtxSize","SM2InitCtx_Free","SM2InitCtxWithPubKey",
    "generatePrivateKey","generatePublicKey","generateKeyPair","SM2Decrypt",
    "SM2Encrypt","SM2Verify","SM2Sign",
    "SM3CtxSize","SM3Init","SM3UpdateFinal","SM3","SM3_hmac_steps","SM3_hmac","SM3KDF",
    "generateSM4Key","SM4_CBC_Encrypt","SM4_CBC_Decrypt","SM4_CBC_Encrypt_NoPadding",
    "SM4_CBC_Decrypt_NoPadding","SM4_ECB_Encrypt","SM4_ECB_Decrypt","SM4_ECB_Encrypt_NoPadding",
    "SM4_ECB_Decrypt_NoPadding","SM4_CTR_Encrypt_NoPadding",
    "SM4_CTR_Decrypt_NoPadding","SM4_GCM_Encrypt","SM4_GCM_Decrypt","SM4_GCM_Encrypt_NoPadding",
    "SM4_GCM_Decrypt_NoPadding","SM4_GCM_Encrypt_Decrypt_NoPadding_NIST_SP800_38D","SM4_GCM_Encrypt_Decrypt_NIST_SP800_38D",
    "SM4_CBC_Encrypt_Steps","SM4_CBC_Decrypt_Steps","SM4_CBC_Encrypt_NoPadding_Steps","SM4_CBC_Decrypt_NoPadding_Steps",
    "SM4_ECB_Encrypt_Steps","SM4_ECB_Decrypt_Steps","SM4_ECB_Encrypt_NoPadding_Steps","SM4_ECB_Decrypt_NoPadding_Steps",
    "SM4_CTR_Encrypt_NoPadding_Steps","SM4_CTR_Decrypt_NoPadding_Steps","SM4_GCM_Encrypt_NoPadding_Steps","SM4_GCM_Decrypt_NoPadding_Steps",
    "SM2DecryptWithMode",
    "SM2EncryptWithMode","SM2VerifyWithMode","SM2SignWithMode"
    };
const static TEST_FUNC_T INTERFACE_TEST_METHODS[]
    = {test_Version,test_SM2CtxSize, test_SM2InitCtx_Free, test_SM2InitCtxWithPubKey,
    test_generatePrivateKey,test_generatePublicKey,test_generateKeyPair,test_SM2Decrypt,
    test_SM2Encrypt, test_SM2Verify, test_SM2Sign,
    test_SM3CtxSize, test_SM3Init,test_SM3UpdateFinal,test_SM3,test_SM3_hmac_steps,test_SM3_hmac,test_SM3KDF,
    test_generateSM4Key,test_SM4_CBC_Encrypt,test_SM4_CBC_Decrypt,test_SM4_CBC_Encrypt_NoPadding,
    test_SM4_CBC_Decrypt_NoPadding,test_SM4_ECB_Encrypt,test_SM4_ECB_Decrypt,test_SM4_ECB_Encrypt_NoPadding,
    test_SM4_ECB_Decrypt_NoPadding,test_SM4_CTR_Encrypt_NoPadding,
    test_SM4_CTR_Decrypt_NoPadding,test_SM4_GCM_Encrypt,test_SM4_GCM_Decrypt,test_SM4_GCM_Encrypt_NoPadding,
    test_SM4_GCM_Decrypt_NoPadding,test_SM4_GCM_Encrypt_Decrypt_NoPadding_NIST_SP800_38D,test_SM4_GCM_Encrypt_Decrypt_NIST_SP800_38D,
    test_SM4_CBC_Encrypt_Steps,test_SM4_CBC_Decrypt_Steps,test_SM4_CBC_Encrypt_NoPadding_Steps,test_SM4_CBC_Decrypt_NoPadding_Steps,
    test_SM4_ECB_Encrypt_Steps,test_SM4_ECB_Decrypt_Steps,test_SM4_ECB_Encrypt_NoPadding_Steps,test_SM4_ECB_Decrypt_NoPadding_Steps,
    test_SM4_CTR_Encrypt_NoPadding_Steps,test_SM4_CTR_Decrypt_NoPadding_Steps,test_SM4_GCM_Encrypt_NoPadding_Steps,test_SM4_GCM_Decrypt_NoPadding_Steps,
    test_SM2DecryptWithMode,
    test_SM2EncryptWithMode,test_SM2VerifyWithMode,test_SM2SignWithMode
    };
const static int METHODS_LEN = sizeof(INTERFACE_METHODS_NAME)/sizeof(char*);

void testInterface(const char* name) {
    TEST_FUNC_T funp = NULL;
    if(name == NULL) {
        cout << "interface: method " << name << " is null!\n";
        return;
    } else if(strcmp(name, "all")==0) {
      for(int i = 0; i < METHODS_LEN; i++) {
          funp = INTERFACE_TEST_METHODS[i];
          if(funp() == RET_OK) {
              // fprintf(stdout, "testInterface: %s is OK\n", name);
              cout << "ability: " << INTERFACE_METHODS_NAME[i] << " is OK\n";
          } else {
              cout << "ability: " << INTERFACE_METHODS_NAME[i] << " is error!\n";
          }
      }
      return;
    }
    for(int i = 0; i < METHODS_LEN; i++) {
        if(strcmp(INTERFACE_METHODS_NAME[i], name) == 0) {
            funp = INTERFACE_TEST_METHODS[i];
        }
    }

    if(funp != NULL) {
      
        if(funp() == RET_OK) {
            // fprintf(stdout, "testInterface: %s is OK\n", name);
            cout << "interface: " << name << " is OK\n";
        } else {
            cout << "interface: " << name << " is error!\n";
        }
    } else {
        cout << "interface: method test_" << name << " not found!\n";
    }
}
